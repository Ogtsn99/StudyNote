## １章 ソフトウェアエンジニアリングとは何か

### 時間
ソフトウェアエンジニアリングにおいて、ソフトウェアの持続可能性は重要。変化に対応できるようにするべきだ。
最初のアップデートを切る抜けるだけでなく、その後も最新版に追随できる状態にすることがプロジェクトの長期的持続可能性の真髄である。
**Hyrumの法則**
あるAPIに十分な数のユーザーがいるとき、APIを作った者自身が契約仕様としてなにを約束しているかは重要ではない。 **作られたシステムがもつあらゆる観察可能(observable)な挙動に関して、それに依存するユーザーが出てくるものである**。
そこに少しでも複雑さがあれば、将来的に挙動が変わる可能性がある。そして、Hyrumの法則によってその影響を受けるユーザはいるはず。脆い、未公開の機能に依存したコードは、クレバーと言われるが、クレバーが褒め言葉で使われるならそれは「プログラミング」で、悪口で使われるなら「ソフトウェアエンジニアリング」である。
変化それ自体のために変化するべきではないが、変化の能力は備えていなければならない。
### スケール
基本的に複数人で行うので、人数が増えてもうまくスケールし、効率性を落とさないことが重要だ
人件費、計算リソース、そしてコードベースもスケールする必要がある。全体ビルド一回の時間やプログラミング言語のアップデートに対するコストは気づかないうちに大きくなっていく
1.2.1
チャーンルールは、専門家が自分自身で顧客を新バージョンに移行させるか、システムを止めずに後方互換性のある形のどちらかにしなければならないというルール。これは割とスケールする。全顧客に対応法を考えてもらうより、専門家グループを作る方がさっさと終わる。
知識はウイルスのような拡散性がある
1.2.2
Beyonceルール ... テストで検知できない問題はインフラチームの責任ではない。（テストを書いておけばよかったのに）
1.2.3
Googleは2006年のコンパイラのアップデートに非常に苦労した。BeyonceルールもCIシステムも浸透しておらず、リグレッションを出しても責められないという確信を持つことが難しかった。->Googleはスケーリングの問題を克服し、長所に変えるべく、自動化、統合/一貫性、専門知識に注力し始めた。
コードベースの柔軟性に影響する要因は専門知識（アップグレードの方法を知っていること）、安定性（リリースを定期的に、頻繁にしており、リリース間での変化が少ない）、準拠性（アップグレードをすでに経ていないコードはほとんど存在しない）、馴染み深さ（アップグレードを十分に定期的に実施しているので、そのプロセスの冗長性を見出し、自動化できる）、ポリシー（Beyonceルールのようなプロセスやポリシーを有しているか）
1.2.4 左への移動
問題を早期発見するとコストが下がる
### トレードオフ
少ないメトリクス（指標）でトレードオフの判断を迫られる。選択肢は無数にあることが多い
全ての決定にはきちんとした理由を伴うべきである
決定は、私がそういうのだからそうするべきだ、で行ってはならない
1.3.1
ホワイトボードマーカーが切れないよう大量に購入した。思考が途切れるのを防ぐことを優先した結果である。
1.3.2
計測可能 or 計測不可能な2パターンの決定がある。
1.3.3
予期せぬコストが発生することもある。分散ビルドシステムを作ったら、エンジニアがあまり最適化をしなくなってしまった。
1.3.5
決定にその時点でのデータを活用したとしても、時間の経過で新たなデータが入ってきて、コンテキストが変化し、決定が間違いであったことがわかるということもあるだろう。決定者は必ず間違いを認める権利を有すべきで、間違いを認めることは尊敬を勝ちとりこそすれ、失うことはない。
### ソフトウェアエンジニアリング vs プログラミング
ソフトウェアエンジニアリングはプログラミングの上位に位置するなどということはない。制約、価値、ベストプラクティスが異なるというだけの話である。例えば、数日間のみ使用するプログラムにはCIや統合テストは不要である場合が多い。
プログラミングはコードを生産する即時的行動であり、ソフトウェアエンジニアリングはコードを利用しなければならない期間中に有用に保つのに必要であり、また、チームを横断した共同作業を可能にする、ポリシー、プラクティス、ツールのセットである。