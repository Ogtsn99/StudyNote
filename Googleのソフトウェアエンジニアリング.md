## １章 ソフトウェアエンジニアリングとは何か

### 時間
ソフトウェアエンジニアリングにおいて、ソフトウェアの持続可能性は重要。変化に対応できるようにするべきだ。
最初のアップデートを切る抜けるだけでなく、その後も最新版に追随できる状態にすることがプロジェクトの長期的持続可能性の真髄である。
**Hyrumの法則**
あるAPIに十分な数のユーザーがいるとき、APIを作った者自身が契約仕様としてなにを約束しているかは重要ではない。 **作られたシステムがもつあらゆる観察可能(observable)な挙動に関して、それに依存するユーザーが出てくるものである**。
そこに少しでも複雑さがあれば、将来的に挙動が変わる可能性がある。そして、Hyrumの法則によってその影響を受けるユーザはいるはず。脆い、未公開の機能に依存したコードは、クレバーと言われるが、クレバーが褒め言葉で使われるならそれは「プログラミング」で、悪口で使われるなら「ソフトウェアエンジニアリング」である。
変化それ自体のために変化するべきではないが、変化の能力は備えていなければならない。
### スケール
基本的に複数人で行うので、人数が増えてもうまくスケールし、効率性を落とさないことが重要だ
人件費、計算リソース、そしてコードベースもスケールする必要がある。全体ビルド一回の時間やプログラミング言語のアップデートに対するコストは気づかないうちに大きくなっていく
1.2.1
チャーンルールは、専門家が自分自身で顧客を新バージョンに移行させるか、システムを止めずに後方互換性のある形のどちらかにしなければならないというルール。これは割とスケールする。全顧客に対応法を考えてもらうより、専門家グループを作る方がさっさと終わる。
知識はウイルスのような拡散性がある
1.2.2
Beyonceルール ... テストで検知できない問題はインフラチームの責任ではない。（テストを書いておけばよかったのに）
1.2.3
Googleは2006年のコンパイラのアップデートに非常に苦労した。BeyonceルールもCIシステムも浸透しておらず、リグレッションを出しても責められないという確信を持つことが難しかった。->Googleはスケーリングの問題を克服し、長所に変えるべく、自動化、統合/一貫性、専門知識に注力し始めた。
コードベースの柔軟性に影響する要因は専門知識（アップグレードの方法を知っていること）、安定性（リリースを定期的に、頻繁にしており、リリース間での変化が少ない）、準拠性（アップグレードをすでに経ていないコードはほとんど存在しない）、馴染み深さ（アップグレードを十分に定期的に実施しているので、そのプロセスの冗長性を見出し、自動化できる）、ポリシー（Beyonceルールのようなプロセスやポリシーを有しているか）
1.2.4 左への移動
問題を早期発見するとコストが下がる
### トレードオフ
少ないメトリクス（指標）でトレードオフの判断を迫られる。選択肢は無数にあることが多い
全ての決定にはきちんとした理由を伴うべきである
決定は、私がそういうのだからそうするべきだ、で行ってはならない
1.3.1
ホワイトボードマーカーが切れないよう大量に購入した。思考が途切れるのを防ぐことを優先した結果である。
1.3.2
計測可能 or 計測不可能な2パターンの決定がある。
1.3.3
予期せぬコストが発生することもある。分散ビルドシステムを作ったら、エンジニアがあまり最適化をしなくなってしまった。
1.3.5
決定にその時点でのデータを活用したとしても、時間の経過で新たなデータが入ってきて、コンテキストが変化し、決定が間違いであったことがわかるということもあるだろう。決定者は必ず間違いを認める権利を有すべきで、間違いを認めることは尊敬を勝ちとりこそすれ、失うことはない。
### ソフトウェアエンジニアリング vs プログラミング
ソフトウェアエンジニアリングはプログラミングの上位に位置するなどということはない。制約、価値、ベストプラクティスが異なるというだけの話である。例えば、数日間のみ使用するプログラムにはCIや統合テストは不要である場合が多い。
プログラミングはコードを生産する即時的行動であり、ソフトウェアエンジニアリングはコードを利用しなければならない期間中に有用に保つのに必要であり、また、チームを横断した共同作業を可能にする、ポリシー、プラクティス、ツールのセットである。

## 2章 チームでうまく仕事をするには
結論:「謙虚、尊敬、信頼」とういう中心原則をめぐる自身の行動を改革することが、チームで成功するための鍵である 2.2
超有名な天才であっても、一人では成し遂げられなかっただろう。
未完成の作品を見られ、レベルの低さがバレて馬鹿にされるかもしれないという恐怖から、人は自分の作業を隠したがる。だが、仕事の隠蔽は大問題である。
2.3
単独作業に全ての時間を費やすと、不要な失敗や成長のリスクを逃す恐れがある。
2.3.1
良いアイデアを思いついたと思っても、根本的な欠陥がある可能性がある。人に見せてフィードバックをもらうことで、このリスクを減らせる。
2.3.2
バス係数。バスに轢かれることはなくても、結婚や退職など、予期せぬ事件は起こりがち。単独作業の場合、バスに轢かれるとプロジェクトは一巻の終わりである。また、複数人で作業をすると、行き詰まった時に助けてくれる。
2.3.3
なる早でフィードバックを得よ、テストせよ、セキュリティと本番環境について考慮せよ。
2.3.4
要するに隠れるな。
2.4
ソフトウェアエンジニアリングとは、チームによる取り組みである。
2.4.1
「謙虚、尊敬、信頼」が、共同作業の理想郷への辿り着くための3つの柱である。
謙虚...自己研鑽に対して開かれた存在が自分である。
尊敬...共に仕事をする他者を心から思いやる。
信頼...他者が有能で正義をなすであろうと信じ、適切な場合には他者に舵取りを任せることに異存がない
2.4.2
小さな人付き合いの構築（軽い上端を行ったり、少し親切に接する）は、十分にpayする
2.4.3.1
順応しようと見せかけるだけでも得をする。そうでなれば、ちょっとずつその代償が累積していく。
2.4.3.2
批判は相手を尊敬し、建設的なものにする。
自分という存在と、自分のコードとは別である。自分のコードを否定されたからといって、自分が否定されているわけではない。また、批判を受けた場合にも、相手を信頼し、自分のためを思ってやってくれていると認識する必要がある。フィードバックには謙虚さが必要である。質問を相手に関してではなく、自分に関するものとする工夫を凝らす。
2.4.3.3
1000万ドルという大金を失う大失敗を犯し、辞表を出そうとした重役に対し、CEO「1000万ドルのトレーニング代を払ったばかりなので、解雇はしない！」といった話。失敗は選択肢の一つなのである。失敗することがなかったとすれば、十分に革新的ではないか、十分にリスクをとっていないかのどちらかである。
2.4.4
失敗すると、適切なポストモーテム（事後分析）を行うことが重要だ。失敗を適切にドキュメントすることで、後に続く者の役に立つ。  
適切なポストモーテムは以下を含むだろう。
- 分析対象イベントの要約
- 発見から調査を経て解決に至るまでの分析対象イベントのタイムライン
- 分析対象イベントの主要原因
- 影響と損害の評価
- 問題を直ちに修正するための一連のアクションアイテム（要処理事項とそのオーナー）
- 分析対象イベントが再発するのを防ぐための一連のアクションアイテム
- 学んだ教訓
2.4.4.2
他の誰かのせいで自分の考えが変わる事は問題ない。
過ちを犯したことや、自分の力量が全然足りないことを認めると長い目で見れば自分の信望を高められる。できることのうち「わからない」と言うのが最善なこともあるのだ。
2.4.5
「Google的」であることは、以下の要素を兼ね備えていることと結論づけられた。また、以下を定義した後は、曖昧さをはらんだ「Google的」は使われなくなった。
**曖昧さの中にあっても成功する**
環境が絶えず変化している最中であっても、互いに競合する複数のメッセージや複数の方針に対処でき、合意を形成でき、問題に対して進捗を遂げることができる
**フィードバックを尊重する**
フィードバックを率直に受け、かつ与えるという両方を行える謙虚さを持ち、フィードバックの重要性を理解している
**現状に立ち向かう**
他者からの抵抗や惰性があろうと、野心的なゴールを設定し追求することができる
**ユーザを第一におく**
Google製品のユーザへの共感と尊敬に満ち、ユーザの利益を第一に考えた行動を取る
**チームを思いやる**
同僚に共感と尊敬を持ち、頼まれなくても積極的に手伝い、チームの団結力を強める
**正義をなす**
行うこと全てに強い倫理的感覚を持つ。チームと製品の誠実さを守るためなら、こんなんで不都合な決断を行うことも厭わない。
## 3章 知識共有
学びの文化は非常に大切で、それによって専門家の知識を流通することができる
3.1
学びを阻む課題として挙げられるのが、
**心理的安全性の欠如**
**情報の孤島群**
互いにコミュニケーションがなかったり、共有リソースを利用しない組織のさまざまな部分で起きる知識の断片化
**情報の断片化**
**情報の重複**
**情報のスキュー**
**単一障害点**
バス係数に関係する。善意からも発生しうる。
**全か無かの専門知識**
全てを知るものと全く知らないものに分かれた組織。専門家が自分で全てをやろうとして、新たな専門家の育成に時間をかけない場合に起こることが多い。初心者は自力でなんとかすることになり、立ち上がりの速度が低下する。
**猿真似**
理解せずに物真似すること
**幽霊の出る墓場**
コード内にあることが多い、触ったら（システム全体に影響を出す）バグが出る可能性があるから皆が避ける場所
3.2
組織の成功は、組織が擁する人々の育成と、その人々への投資にかかっている。
ドキュメント化された知識はスケーラブルで、人数が増えても問題がないが、トレードオフとして、ドキュメント化された知識は一般的になるので、専門家との一対一のアドバイス良いは適用できる度合いが低いかもしれない。また、情報を最新のものに保つための保守コストもかかる。
組織慣習的（tribal）な知識は個々のチームメンバーとドキュメント化された知識の間隙にある。
3.3
心理的安全性こそが、学びのための最も重要なものである。物事を試せることと、失敗しても安全であると感じられることである。
3.3.1
メンター制度は、メンティーが他にアドバイスを求めるものを知らない場合に話しかけるためのセーフティネットとなっている。健全な組織では、チームメイトは質問に答えてくれるというだけでなく、質問を尋ねること、知らないことを表明すること、そして、互いから学ぶことに関しても寛容なのである。
3.3.2
質問に答える時に、「えっと、実はね」はやめる。知識を鼻にかけたような訂正だからだ。
3.4
**常に学び続けよ、常に質問し続けよ** これが3章で最も重要な部分。
ヌーグラーは立ち上がりに6ヶ月はかかる
シニアであることを誤って、なんでも知っていることと同一視しないこと。リーダが公然と質問したり、知識を書いている部分を表に出したりすると、それにつづいても問題ないのだと他者は励まされる。
質問を受ける側には忍耐と親切さが求められる。
3.4.2
コードを変更する際は、文脈と目的を理解してから自分の変更が依然として妥当かを考える。妥当なら変更すれば良いし、妥当でないなら、そう考える根拠を将来の読者のためにドキュメント化する
3.5
一対一の議論から何かを学んだら、それを未来の自分のために書き留めておこう＆未来の新人のために共有しよう。
3.6
自分の知識を共有する方法として、オフィスアワー、テックトークと講習、ドキュメンテーション、コードがある。
3.7
知識を共有する文化にとって重要なもの
**尊敬**
専門知識があるけど嫌なやつというのはいらない（嫌なやつ無用）。リーダというものは、周囲の資質を引き上げ、心理的安全性を向上させるものだ。嫌なやつは良きリーダーではない。
3.7.1.2
組織の制度レベルで知識の共有を表彰し、褒賞を与えるべき
Googleにおいてはピアボーナスやクードスがあり、知識共有をした者はボーナスが与えられ、また、同僚からも認められる
3.7.2
中央集権的でカノニカルな情報源の作成と保守はコストが高く時間がかかるものの、組織全体が対象となり、需要の高い知識を伝搬しやすい。更新されていないことに気づいても、その人が専門知識を持っていない可能性が高いため、オーナーを決定するのが重要である。
開発者ガイド、goリンク（Google社内のurl短縮ツール）、google codelabによる実践的なドキュメント、静的解析などが利用される
3.8 リーダビリティ
Googleではreadabilityは単に読みやすさだけを意味しない。Googleの全社的にプログラミング言語のベストプラクティスを普及するための標準的なメンター制度となっている。現在、Googleのエンジニアの20%がレビュワーおよびコード作者としてリーダビリティプロセスに参加している。
3.8.1
リーダビリティプロセスはリーダビリティ認定を持っている人によって行われ、対象はすべてのCL(Change Line)である。すべてのCLは認定された人によって承認される必要がある。最初コメントを受けることが多かったエンジニアは、だんだんと少なくなっていき、最終的に「リーダビリティがある」と認められる。
3.8.2
リーダビリティプロセスはベストプラクティスを強制と同時に伝搬させるメカニズムであるが、エンジニアの時間を無駄にしているという意見もある。EPR（エンジニア生産性研究）チームの調査で、リーダビリティはエンジニアリングの速度に対し、総じて良い影響を与えることが示された。
## 4章 公正のためのエンジニアリング
多様性について議論していく。正解を見出せていないばかりか、Googleは弱者と見なされるユーザを守れなかった多くの過去の失敗があるが、むしろそのために本章を書き進める。
4.1
バイアスは誰にでも、無意識に存在している。
Googleは白人またはアジア人の男性が非常に多く、低代表（=弱者とみなされる要素を持った集団。女性や少数民族など）グループを十分に考慮できないことが多かった。低代表、弱者のユーザを理解するためのダイバーシティがGoogleに備わっていない場合が多いということだ。
例えば、AIが黒人をゴリラと認識してしまうという有名な事例などがある。技術自体は悪いものではない。Googleのエンジニアも非の打ちどころのない教育、専門的経験を経てきた技術者だ。対処法として、ソフトウェアエンジニアリング組織自体が、Googleが開発する製品の対象である母集団に似通っていくように促す、ということを挙げる。（少数民族や女性を優先的に採用、昇進させたりするのも一種の差別であるという意見もありそうではあるが...）
4.2
卓越したエンジニアには、製品の設計実装に多様な観点を持ち込む必要がある。多様性のかけたエンジニアリングチームになっている場合、全ユーザに向けて開発する方法をここのエンジニアが学んでいかなければならない。
4.3
エンジニアには技術面での才能を有することを期待されるが、同時に、何かを開発すべき時、そうでない時を知る識別力も有している必要がある。自分が手がける製品に、自分が思っている以上の影響力を社会にもたらす可能性があることを考慮するべきだ。その最初のステップとして、自身の持つ偏見を認識する必要がある。
4.5
多様な人種を採用するには採用経路を改めれば良いだけ、という一本槍の思考は良くなくて、採用後に低代表グループの人々が働きやすいかなど、さまざまな観点を考慮する必要がある
4.6
すでに確立されたプロセスも不当な結果を推進するものがないか疑う必要がある
## 5章 チームリーダー入門
Googleには2種類の異なるリーダーがいる。一つはマネージャーで、人員のリーダとして役割を果たす。もう一方は、テックリードであり、技術的取り組みをリードする。テックリードとマネージャーを同時にこなす、テックリードマネージャーがいることもある。
 5.1
**エンジニアリングマネージャー**
Googleは早い段階で、エンジニアリングのバックグラウンドを持つ人をマネージャーに据えることを決定した。チームが担当する製品がビジネス要件を満たすことを保証しつつ、その上でテックリードを含むチーム内の全ての人員の成績、生産性、満足度について責任を持つ。
**テックリード（TL）**
製品の技術的側面を担当し、技術的な決定と選択、アーキテクチャー、優先度、開発速度、プロジェクト管理一般を担う。大半のTLはICでもあるので、自身で何かを手っ取り早くやってしまうか、それをチームメンバーに任せて（場合によっては）より時間をかけて行わせるかのどちらかの選択を強いられる。チームの規模と力量が上がるにつれ、ほとんどの場合に後者がTLにとっての正しい選択となる。
**テックリードマネージャー（TLM）**
初期段階の小規模チームではTLMがいるのがデフォルトである場合が多い。チームでの人員面と技術面の両方の要求に対処できる1人の人物である。比較的シニアなものがTLMであることもあるが、通常は、最近までICだった者がこの役職を務めている。Googleでは基本的にTLMは採用せず、二人でやっていることが多い（両方の業務を同時にうまくこなすのは本当に難しいため）
5.2
気づいたらリーダーになっていた、というのはあるあるらしい。たとえ絶対にマネージャーにはなるまいと自分に誓っていたとしても、起こりうる。
5.2.1
エンジニアがマネージャーになることを避ける理由として、
- 仕事が定量的でないため、今日はこれだけコードを書いたぞ、というのがない。マネジメント業務が忙しい日には、「今日は全く何もやらなかったな」と思っているのに気づくだろう。
- 「ピーターの原理」（階層制度の中では、どの従業員もその従業員が無能とみなされるレベルまでは昇進する傾向がある）。Googleは昇進前に、そのレベルの職務レベルをこなすように要求することで回避している。
マネージャになる理由として、
- 自分自身をスケールさせることができる。自分のリーダーシップのもとで、素晴らしいエンジニアたちのチームがどれだけの量のコードを書けるか想像してみてほしい。
- もしかしたら得意かもしれない。
5.2.2
なんでも管理しようとするのは良くない結果に終わる可能性がある。この対処法として、サーバントリーダーシップがある。サーバントリーダシップは執事や家令のように業務を行うこと（チームメンバーが自分自身で取り除けないものの除去や、合意形成の手伝い、オフィスでチームが遅くまで仕事をしている時に夕食を買ってくる等）である。必要時にはアドバイスを行なったり、自ら手を動かすことを厭わない。
5.3 エンジニアリングマネージャー
労働者を、荷車の御者がラバを扱うのと同様に扱っていたマネージャーは過去の話であり、時代錯誤的である（今でもやっているところはあるが...）
組み立てラインの労働者と違い、ソフトウェアエンジニアは新チームでの業務についていける一人前の戦力になるのに何ヶ月もかかる場合がある。
マネージャーと従業員の関係は親と子の関係ではない。
本章で最も大切なことは↓
**伝統的なマネージャーは物事をやり遂げる方法を気にする一方で、優れたマネージャーはどんな物事かやり遂げられるのかを気にする（やる方法はチームに任せる）**
5.4 アンチパターン
**推しに弱い者を採用する**
むしろ、あなたより賢くて交代できる者を採用するべき。時に反対意見を言うこともあるだろうが、それは良いことである。
**成績の悪い者を無視する**
期待に達しない人はいる。最も難しい場合には、職務遂行能力が全くない者もいる。成績の悪い者を無視（対処しない）すると、どうなるか。それは、現在いる成績の良い者にチームをさるよう促す行いでもある。最終的には、全員成績の悪いチームになるのが落ち。
成績の悪い者をチームに留めておくことは、成績の悪い者に対してなんの思いやりにもなっていない。成績の悪い者が他のチームに移って、大きな影響力を実際に発揮する可能性が往々にしてあるからだ。
成績の悪い者は生産性が高まった状態に移るために激励や方向付けを必要としているだけだったりする。それを放置するとその者とチームの関係が拗れる可能性がある。
成績の悪い者を効果的に指導する方法として、成績の悪い者に特定の期間と達成を期待される非常に具体的なゴールを設定する。ゴールは小さく、インクリメンタルで、計測的にするべきだ。
**人間的問題を無視する**
**全員の友人になる**
全員の友人になろうと振る舞う必要はない。あなたがキャリアに関わる権限を持っているなら、相手はプレッシャーを感じているかもしれない。
**採用基準で妥協する**
定員を満たすように採用をするかもしれないが、それでも、基準に満たないものは切っておくべし
**自分のチームを子供のように扱う**
信頼できる人間を集めるべし。
5.5 建設的パターン
**エゴを捨てる**
自分のエゴを捨て、代わりに、集団的なチームとしてのエゴと主体性を育成、強化すべき。ゴールへの道はあなたではなく、チームで決定する。すべてをうまくやるという重圧を捨て、失敗した時にはごめんなさいをするべき。
5.5.2
平静を保つ。マネージャーの歯車が回れば、多くのICの歯車に影響が出る。
5.5.3
触媒となり、合意形成を助ける
5.5.4
チームが障害にぶつかって停滞してしまった時は助け舟を出そう。適切な人を紹介できるかもしれない。適切な人物を知っているというのは、多くの場合、正しい答えを知っていることよりも価値がある。
5.5.5
先生かつ、メンターになれ。メンターに必要なものは、1. チームのプロセスとシステムについての経験、2. 他者に物事を説明する能力、3. メンティーがどれだけ助けを必要としているか推し量る能力。特に3つ目が大事
5.5.6
明確なゴールを設定する。簡潔なミッションステートメントを作ることでチームメンバーのリソースを効率的に扱うことができる。
5.5.7
情報共有できないことを聞かれたら、知っているが言えないといい。知らないことを聞かれたら素直に知らないというべき。
Googleでは推奨されていないこととして、多くのマネジメントの教科書に書いてある、厳しいフィードバックを与える時には「褒め言葉のサンドイッチ」を使うというアドバイスがある。
直接的で明確なフィードバックと方向付けをしてあげる。悪意があると思われないため、伝え方は鍵になる。多少のユーモアを交えることで、悪意がないことを表現できるかもしれない。
5.5.8
チームの満足度を追跡調査するための簡単で優れた方法は、毎回の1:1面談の最後にチームメンバーに「何が必要かな」を尋ねること
5.7
秘訣集
- チームを混沌から守る
- チームの上空援護をする（上からの情報で重要なものは伝える）
- 元に戻すのが簡単なことは「イエス」を出していいが、10年くらい保守しなければいけない機能などはよく考えるべし
5.8
動機づけと方向づけが成長に必要。方向づけは正攻法だが、動機づけはちょっと精緻なところがある
動機づけには内発的と外発的があるが、内発的の方が重要。自主性、熟達、目的の3つが内発的動機を向上させられる。
自主性は、オーナーシップ意識を与えること
熟達は、エンジニアに既存のスキルを伸ばし、新たなスキルを学び機会を与えること
目的は、チームが努力する理由を提示すること。例えば、どのように顧客のビジネスを支援したかについて語っているメッセージを見つけたら、エンジニアリングチームに転送する。
## 6章 スケールするリーダー
率いるチーム数が複数になるのは自然な流れ。
真に優れたリーダーへ自分をスケールさせるには、「3つのいつでも」が鍵となる
6.1 いつでも決断せよ
曖昧な問題の解決方針決定のプロセスは、目隠しを特定、トレードオフを特定、最後に決定を行い、解法を反復する
目隠し ... 経験からくる憶測のせいで頭が固くなっていること
トレードオフ ... 銀の弾丸はなく、現時点で最良の答えを選ぶため、トレードオフ群を指摘し、それを皆に説明し、どのようなバランスを取るかという決定を補助するのがあなたの役目
決定を反復 ... 次の月には状況が変わるかもしれないので、トレードオフ群を再評価し、バランスを再調整する。
6.2 いつでも立ち去れ
自分がSPOFにならないために注意が必要である。
6.2.1 「自動運転」チームを構築する
複数のチームをまとめて率いることは、人間たちを組織することであることが多い。
6.2.2
解決困難な問題は複数の難しい部分問題からなっていることが多い。いくつかの部分問題に分割し、各チームにそれらを担当させよう。
6.2.2.3
小さな方向づけは非常に価値のあるものだ。優れたマネジメントの95%は観察と傾聴で、5%が目指す方向に印をつけることである。
6.2.2.4
チームに担当させるのは製品ではなく問題であるべき。
6.3 いつでもスケールせよ
マネージャーとチームを率いて成功すると、報酬とともに新しい問題が舞い降りてきて、同時に解決しなければならないため、半数の人員、時間で解決を求められる（圧縮ステージ）
問題を圧縮する行為は自チームの効率化だけでなく、自分の時間と注意力を新しい責任範囲に見合うようスケールさせることである
6.3.2
マネージャーになると、行動がリアクティブ（反応的）になってくる
問題には緊急なものと重要なものがある。重要なものに時間を割くには、移譲や集中する用の時間を確保しておく、todoリストなどの追跡システムを（色々試して）見つけるなどがある
6.3.3
こんまり片付け術のように、重要度の上位20%をやるようにする
6.3.4
自身のエネルギーの管理には
- メールなどのつながりを断って本物の休暇を取る
- そのために、繋がりを断ちやすいようにする（アプリ管理などiosでできるかわからないが）
- 本物の「週末休み」
- 日中にも休憩（散歩したり...）
- メンタルヘルスの日を取ることを自分に許す
## 7章　エンジニアリング生産性の計測
エンジニアの生産性それ自体に専念する専門家のチームを要することは非常に有用かつ重要
7.1
ソフトウェアエンジニアリングの生産性を改善するだけでなく、その改善を継続することがゴール
7.2
まずは**トリアージ**のプロセスから始まる
トリアージでは、生産性の計測の前に、最初に具体的な質問を用意する
**どのような計測結果を期待しているのか、またそれはなぜか**
**期待した計測値を得た場合、どんな行動を取るのか**
**否定的な計測値の場合、適切な行動がとられるか
計測結果に対して行動に出ることを決定するのは誰か、そしていつ決定するのか**
計測の成功は、決定を行うのに必要なデータを利害関係者に与えているということである。
7.3
メトリクス作成にはGSM（Goal/Signals/Metrics）フレームワークを利用する
- **ゴール**は望ましい最終結果
- **シグナル**は、最終的な結果を達成したことを知る方法だが、計測できないかもしれない
- **メトリクス**はシグナルの代用品。これは計測可能。
GSMの特徴
- 街灯効果を予防できる。（見える、計測できるところだけを探しても落とした鍵は見つからないかも）
- 実際に結果を測定する前に適切なメトリクスの組み合わせを見つけるように促すことができる
- どこが計測の対象範囲となっているか、あるいはなっていないかを示せる
**ゴール**
生産性内部のトレードオフを忘れがちなので注意して決める。
QUANTSを評価しよう。
Q ... Quality of the Code
A ... Attention from engineers （どのくらいの頻度でエンジニアがflowに入るか、通知でどのくらい気が散るか、ツールはエンジニアに頭の切り替えを促すか）
N ... Intellectual Complexity 
T ... テンポと速度
S ... Satisfaction
**シグナル**
ゴールに達していると認められる現象が起きているか。例えば、リーダビリティプロセスでベストプラクティスをエンジニアが学べることをゴールとしている場合、エンジニアがリーダビリティからの学びを報告していればゴールに達している。
シグナルおよびメトリクスはゴールに対して一つであるとは限らない。
**メトリクス**
シグナルをどう計測するかを最終的に決定する場である。メトリクスはシグナルの代替品として使用可能である。
## 8章 スタイルガイドとルール
8.1 なぜルールを設けるのか
ルールを設けることで「良い」とされる行動を促すことができる。
8.2 ルールを作る
ルールを作る際に尋ねるべきは「どんなゴールを前進させようとしているのか」である。
ルールを作る時の包括的原則
**ルール側のルールと同様に有用でなければならない**
**（コードの）読者に向けて最適化せよ**
**一貫性を保て** ... どのオフィスも同じように働けるように. これで, より効率的に働けるようになる
**誤りの起きやすく意外な構文は避けよ**
**現実問題に譲歩せよ** ... 例外も認める
スタイルガイドには
**危険を避ける** ... バグが入り込みにくく、保守性のある言語利用を推奨
**ベストプラクティスを強制する**
**一貫性を組み込む** ... 延々続く議論はせず、決定を行うことが重要
8.3
状況が変わってきて、ルールを変更することはあり得る
変更の必要性は大体それを書いているエンジニアが最初に気づき、スタイルガイド関連議論専用の言語特有メーリングリストから始め、質問するか変更を提案できる。
8.3.2
スタイルガイドについての最終決定はスタイルガイドオーナーであるスタイル調停者によって行われる
8.3.3
例外については、調停者にルール適用の免除を求めることができる（ただし、認められないことも多い）。また、ルールを違反するのが違反を回避するよりも有益だと判断される場合、例外は許容される
8.4
ガイダンスが対象とするのは間違いやすいこと、混乱に陥りやすいこと。ルールが「絶対にやらなければならないこと」だとしたら、ガイダンスは「やるべきこと」である。
8.5
ルールは教育とトレーニングを通じて、人々の間で社会的に守らせることも可能だし、技術的にはツールで守らせることもできる。
8.5.1
エラーチェッカーを導入することで、ルール遵守のコストを下げることができる
8.5.2
gofmtなどのコードフォーマッターも同様である
## 9章 コードレビュー
コードレビューは基本的にプロセスとツールの二つが必要。
基本フローは、変更->レビュー依頼->フィードバック->修正->同じ人に再度レビュー依頼->LGMT
9.2
コードレビューでは、
- コードが適切で作者が主張する通りの動作をするという正しさの確認
- コードが、コードベースのその特定の部分に対して適切であるというもの
- リーダビリティを持つものによる、ベストプラクティスに従っていることの承認
の3つの側面がある
9.3 
コードレビューを行うことで確かに任意のコード変更が本番環境に出るまでの時間に影響を与えるが、レビュープロセスとコードレビューを真摯に受け止める文化は以下のようなメリットをもたらす。
- コードの正しさをチェックする ... コードが意図通りに動くか、バグを孕んでいないかをチェック。バグは早めに見つかった方が結果的に短い時間で済む
- コードの変更が、他のエンジニアにとって意味を把握できる物であることを保証する ... コードは複数人から読まれる物なので、他の人が理解可能かどうかをチェックする
- コードベース全体での一貫性を強制する ... コードがベストプラクティスに従っており、過度に複雑になっていないかを、その言語のリーダビリティのあるエンジニアからの承認を要する
- チームのオーナーシップを心理的に促進する ... コードが自分個人のものではなく、チームのものであるという認識を強化する。また、コードレビュープロセス自体が批判的なレビューを要求するものなので、レビュアーもレビュイーも心を傷つけにくい。
- 知識共有を可能にする
- コードレビュー自体の履歴の記録を提供する
9.4 コードレビューのベストプラクティス
9.4.1 礼儀正しく、かつプロフェッショナルになれ
レビュアーは作者の特定アプローチについて、作者を尊敬すべきであり、そのアプローチが不十分な場合にのみ代案の指摘を行うべき。
レビューを経てもアプローチに欠陥が発見された場合は、そのレビューを双方にとっての学びの機会と考える。
レビュアーは、迅速にフィードバックを行う。24時間以内が期待される。無理そうなら、なるはやでレビューしますと返信を送っておく。
コードレビューに少しずつ断片的に返信するのも良くない。
コードレビューにつけられたコメントはTODO項目として扱う。全てを受け入れる必要はないが、コメントへの対処は行うべき。
作者がレビューに同意しない場合、代案を出してレビュアーにPTAL（Please take another look）を依頼する
9.4.2 小さな変更をかけ
コードの変更は理解しやすいように小さなものであるべき。完全なプロジェクトの形をとるものが複数入っている大規模な変更についてじゃ、レビュアーは一回のレビューには大きすぎるとして正当に拒絶することができる。
「小さな変更」は約200行までのコードに限定されるべきだ。
小さな変更であれば、その日中に終わらせやすい。また、誤ったアプローチに多くの労力を注ぎ込むことも防げる。
9.4.3 良い変更説明をかけ
変更説明の一行目は超重要で、ここに要約としてその変更がどんな種類のものかを示すべきだ。最初の行では、変更全体の要約となるが、何が変更されていて、なぜ変更されるのかの詳細についても説明が必要。
9.4.4 レビュアーの人数は最小限にとどめよ
Googleではレビュアーは大体一人。別部署のエンジニアから追加的な意見を得ようとする風潮があったりするが、すぐにレビュアーを追加したことによるコストがメリットを上回る。追加のLGTMはあんまり重要ではない。
9.4.5 可能な場合は自動化せよ
テスト、リンター、フォーマッターの実行を作者に要求するのではなく、リポジトリ提出前処理として、レビュアーに送られる時に自動で処理され、その結果、多様な問題を検出したり、変更を却下したり、まず変更を修正するように元の作者に依頼したりすることができる。
9.5
Googleのコード変更は大体以下の4種類
- グリーンフィールドレビューと新機能開発 ... 全く新しいコードを追加する
- 挙動の変更、改善、最適化 ... APIの挙動が変わるならテストも修正されるべきである。最適化であればベンチマーク結果も含むべきかもしれない。
- バグ修正とロールバック ... コードの変更はバグ修正に集中し、それ以外の問題には対処するな。また、発生したエラーを捕捉できるようにテストも修正しておくべき。ロールバックするだけでもコードレビューは必要である。
- リファクタリングと大規模変更 ... 機械による変更でもコードレビューが必要。
## 10章 ドキュメンテーション
品質の高いドキュメンテーションの欠如は多くのエンジニアが抱く不満である。
また、ドキュメンテーションは多くの場合、エンジニア自身が書かなければならないだろう。Googleで最も成功せいている取り組みは、ドキュメントを**コードのように扱いつつ**、伝統的なエンジニアリングワークフローへ組み込むことだ
10.1
ドキュメンテーションにはコード内のコメントも含まれる。
10.2
ドキュメンテーションは絶大な恩恵がある。コードやAPIの意味が理解しやすくなり、間違いが減る、新メンバーへのオンボーディングの労力が減る。
ただ、ドキュメンテーションは恩恵をテストほどすぐに得られるわけではなく、特に、作者にはあまり利益がない。
グループと書き手の利益は
- APIの定式化を促す
- 保守のロードマップと履歴の記録を提供する。数年後にコードを読んで間違っている箇所を見つけようとする場合、良質なコメントがあると大いに助けになる
- コードがプロフェッショナルに見える
- 他のユーザの質問回数を減らせる
10.3
ドキュメンテーションはコードのように扱い、以下のようなものであるべき
- 内部的なポリシーかルールを持つ
- ソースコントロールシステムの管理下に置かれる
- ドキュメンテーションにはそれを保守する責任を持つ明確なオーナーシップがある
- 変更についてもレビューを経る
- コードのバグが追跡されるようにドキュメントも問題が追跡される
- 定期的に評価される
- （可能であれば）正確性や鮮度の面で計測される
10.4
ドキュメンテーションを自分のためだけに書くのは大きな間違い。代わりに、そのドキュメントの対象読者を特定するべきだ。
もっと優れたドキュメンテーションを書かないといけないと思うのは間違い。
10.4.1
ドキュメントを短く保つと対象読者を見誤るのを回避しやすい。
自分が欲しいものがわかっているエンジニアに対しては、一貫性を提供するべき。
自分が欲しいものが曖昧な人に対しては、TL;DRをつける（ドキュメントの途中に入れて、「興味のない人はここで読み進めるのをやめることができる」としてもいい）
10.5
一つのドキュメントに複数のことを詰め込んではならない。ドキュメントには必ず唯一無二の目的を持つべき。そのページに何かを追加することが合理的でない場合は、別のドキュメントを探したり、新規作成すると良い。
10.5.1 リファレンスドキュメンテーション
リファレンスドキュメンテーションには、主にAPIコメントと、実装コメントの二種類。APIコメントはより広い範囲を読者としており、実装コメントにはより前提知識を必要とし、コードがその書き方で書かれた理由を説明する。
大半のリファレンスドキュメンテーションは、コードベース自体の中にあるコメントから生成されているべき。GoDocなどのコメント追加フレームワークもある。
10.5.1.1
ファイルコメントは、ファイルの始まりに、何が含まれているかをについての概要を書く。
10.5.1.2
クラスコメントはオブジェクトとしての特徴に重点を置き、Fooクラス、Barクラス、関数xなど、「名詞づけ」を含む
10.5.1.3
関数コメントには、何を行うかを説明する。スタイルガイドは設けず、自然な文体で書く方がわかりやすい。
10.5.2 デザインドキュメント
Googleではほとんどのチームで実作業の着工前に設計を記したデザインドキュメントの提出が求められる。これは、実装前の一種のコードレビューの役割を果たしており、さまざまな懸念点からそのドメインの専門家によりレビューされる。最も優れたドキュメントは設計のゴールを提案し、設計の各種代案を網羅して論じ、それらの代案の強み、弱みを示す。
製品のローンチ前にデザインドキュメントを再レビューし、元のゴールが存続していなければ、ドキュメントか製品のどちらかを適宜調整できる。
10.5.3 チュートリアル
大半のプロジェクトのチュートリアルは何かを実質的に起こせるような「HelloWorld」ドキュメントが用意されているべき。それを作る最もいい機会は、チームに初めて参加するときだ（すでにある時は、それがチュートリアル内のバグの発見に最も良い機会だ）。
10.5.4 概念的ドキュメンテーション
概念的ドキュメンテーションはAPIやシステムの外観を提供し、リファレンスドキュメンテーションを強化する。明確性のためにある程度正確性を犠牲にしても構わない。リファレンスドキュメンテースヨンとの内容の重複も明確性の強調をするために許容される。最も書くのが難しいドキュメンテーション形式で、見過ごされやすい
10.5.5 ランディングページ
ランディングページは目的を明確に特定しているようにし、さらなる情報を得るための他のページのリンク**のみ**を含めるようにする。交通整理の役割を持っていると言える。
10.6 ドキュメンテーションのレビュー
 ドキュメンテーションもレビューを要する。
 - 正確性のための技術的レビュー。大抵専門家によって行われる
 - 明確性のためのレビュー。新人やAPI利用者など、その領域に親しんでいないものによって行われる
 - 一貫性のための作文法レビュー。テクニカルライターもしくは志願者による
 10.7 ドキュメンテーション哲学
 5W1Hを意識して書くべき。Howが最も重要性が高いことが多いが、それ以外も含めるべき。
 エンジニアは冗長性を嫌うが、ドキュメンテーションにおいては冗長性が有益なことがよくある
 10.7.3
 優れたドキュメンテーションには完全生、正確性、明確性の3つの側面がある。優れたドキュメントはその意図された役目をこなしていればよく、これらの3つを同時に満たす必要はない。また、改善したい時には、対象読者から何が求められているのかを考え、それに専念すると良い
 10.7.4 ドキュメントを廃止する
 ドキュメントが古くて何の役にも立っていないなら、削除するか旧版のドキュメントとして識別すべき。ドキュメントにはしばしば鮮度日付といって、そのドキュメントのオーナーと、最終レビュー日が記録されている
 10.8 テクニカルライターはいつ必要か
 Googleはテクニカルライターが昔から不足している。テクニカルライターを重要なプロジェクトに配置したが、それは間違いで、自分たち自身のためのドキュメンテーションなら全く申し分なくかける。テクニカルライターを必要としがちなのは、他の対象読者向けにドキュメントを書いている場合だけである。
## 11章 テスト概観
テストの重要性はバグを早期に補足でき、また、変化を可能とする能力を備えることもできる。例えば、リファクタリングや新機能追加をしても自動テストは間違いを素早く補足できる。
11.1 なぜテストを書くのか
何百、あるいは何千のテストをまとめたものは**テストスイート**と呼ばれる。テストスイートの作成と保守は大変な労力が必要で、それらの対策を怠り、ダメなテストスイートになってしまっては、テストスイートが全くないよりもタチが悪い。
11.1.1
Google Web Serverは、テストがまともになかったため、最大級の被害を受けていた。TLが全ての新規変更にテストを加えるという、テストについてのポリシーを作成し、緊急の本番コードリリースの数は半減した。GWSが教えるものは、製品の欠陥を避けるのに一部の優れたエンジニアに頼るのではないということ。自動テストと手動デバッグでは、エンジニアリングリソース面でのコストに雲泥の差がある。
11.1.3
純粋なテストは書く、実行する、失敗するの3つの活動からなる。QAチームがいても、エンジニアが自分自身のために自動テストを書き、実行する。
健全なテスト文化はテストを書く作業を分担共有を皆に促し、定期的なテスト実行をし、破綻したテストは迅速に修正する。
11.1.4 コードをテストする利点
コードをテストする利点は
- デバッグの減少
- 変更への信頼の増大
- ドキュメンテーションの改善（テスト自体が実行可能なドキュメンテーションとなる）
- レビューの単純化
- 思慮に富む設計（依存関係が多く、蜜結合になっているコードはテストがかなり書きにくいため、結果的にテストを書くために優れた設計になる。）
- 高速で高品質なリリース
11.2 テストスイートを設計する
小さいテストを積み上げる方が、大きいテスト一つよりも良い。
Googleには3つの規模のテストがある。小テスト、中テスト、大テストだ。
小テストは単一のプロセスで実行され、中テストは単一のマシンで実行され、大テストは任意の好きな場所で実行される。
**小テスト**
小テストの制約はsleepできない、IO操作できない、他のあらゆるブロックする関数呼び出しができない。外部の影響を受けないようにすることで、外部要因で失敗する可能性（=非決定性）を排除できる。
**中テスト**
中テストは複数プロセスに広がることができ、localhostへのアクセスが可能。データベースのインスタンスを実行可能だったり、ウェブUIとサーバーの組み合わせのテストもできる。
**大テスト**
大テストはlocalhostだけでなく、複数のマシンにアクセスが許される。単一マシンでの実行に比べ、速度低下と非決定性を招く可能性が著しく増すことに注意。
（Googleでは、非決定性のある信頼不能テストはおよそ0.15%らしい）
11.2.1.4
テストは密閉されているべきで、外部環境についての前提条件はあまり持つべきではない。また、テストコードはシンプルにすべきで、テストコード内でif文やループは非推奨である。
11.2.2
テスト範囲は小さくするべき。ここでの範囲は実行されるコードではなく、検証されるコードである。Googleで目指しているのは大雑把にユニットテスト80%, インテグレーションテスト15%, エンドツーエンド5%くらいだ。とはいえ、読者の状況に応じて異なるバランスが望ましくなるだろう。
11.2.3
テストは破綻したら困るもの全てに用意しておくべきだ。Beyonceルールは、「そんなに好きならそいつにテストつけとけばよかったのに」を意味する。
11.2.4
コードカバレッジはコードで実行されるコードの行の割合を示しているだけで、それで適切にテストされているかはわからない。
11.3
Googleほどの規模だと、テストの書き方が下手だと数行の変更で何十個ものテストが落ちる。また、モックオブジェクトの誤った利用で酷い害を被ったこともある。さらに、テストにかかる時間も多くなる。並列化で高速化を図ることもできるが、ものすごく遅い単一のテストがあればそこがボトルネックとなり得る。
テストが遅く、非決定的だと、テストをすっ飛ばすエンジニアが現れる。
11.4 Googleのテストの歴史
Googleに自動テストの分化を根づけた要因として、オリエンテーション講習、テスト認定プログラム、トイレでのテストの3つが挙げられる。
11.4.1 オリエンテーション講習
社員がテストをあまり書いていないとしても、新しく入ってくる新人にさもテストを書くのが当たり前のように教えることで、トロイの木馬的にテスト分化を導入した。
11.4.2 テスト認定プログラム
テスト認定プログラムはプロジェクトのテストの成熟度を5段階で評価、改善方法を提示するといったもので、これにより各チームは互いに競い合ってテストのレベルを上げようとするようになった。