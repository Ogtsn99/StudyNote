## １章 ソフトウェアエンジニアリングとは何か

### 時間
ソフトウェアエンジニアリングにおいて、ソフトウェアの持続可能性は重要。変化に対応できるようにするべきだ。
最初のアップデートを切る抜けるだけでなく、その後も最新版に追随できる状態にすることがプロジェクトの長期的持続可能性の真髄である。
**Hyrumの法則**
あるAPIに十分な数のユーザーがいるとき、APIを作った者自身が契約仕様としてなにを約束しているかは重要ではない。 **作られたシステムがもつあらゆる観察可能(observable)な挙動に関して、それに依存するユーザーが出てくるものである**。
そこに少しでも複雑さがあれば、将来的に挙動が変わる可能性がある。そして、Hyrumの法則によってその影響を受けるユーザはいるはず。脆い、未公開の機能に依存したコードは、クレバーと言われるが、クレバーが褒め言葉で使われるならそれは「プログラミング」で、悪口で使われるなら「ソフトウェアエンジニアリング」である。
変化それ自体のために変化するべきではないが、変化の能力は備えていなければならない。
### スケール
基本的に複数人で行うので、人数が増えてもうまくスケールし、効率性を落とさないことが重要だ
人件費、計算リソース、そしてコードベースもスケールする必要がある。全体ビルド一回の時間やプログラミング言語のアップデートに対するコストは気づかないうちに大きくなっていく
1.2.1
チャーンルールは、専門家が自分自身で顧客を新バージョンに移行させるか、システムを止めずに後方互換性のある形のどちらかにしなければならないというルール。これは割とスケールする。全顧客に対応法を考えてもらうより、専門家グループを作る方がさっさと終わる。
知識はウイルスのような拡散性がある
1.2.2
Beyonceルール ... テストで検知できない問題はインフラチームの責任ではない。（テストを書いておけばよかったのに）
1.2.3
Googleは2006年のコンパイラのアップデートに非常に苦労した。BeyonceルールもCIシステムも浸透しておらず、リグレッションを出しても責められないという確信を持つことが難しかった。->Googleはスケーリングの問題を克服し、長所に変えるべく、自動化、統合/一貫性、専門知識に注力し始めた。
コードベースの柔軟性に影響する要因は専門知識（アップグレードの方法を知っていること）、安定性（リリースを定期的に、頻繁にしており、リリース間での変化が少ない）、準拠性（アップグレードをすでに経ていないコードはほとんど存在しない）、馴染み深さ（アップグレードを十分に定期的に実施しているので、そのプロセスの冗長性を見出し、自動化できる）、ポリシー（Beyonceルールのようなプロセスやポリシーを有しているか）
1.2.4 左への移動
問題を早期発見するとコストが下がる
### トレードオフ
少ないメトリクス（指標）でトレードオフの判断を迫られる。選択肢は無数にあることが多い
全ての決定にはきちんとした理由を伴うべきである
決定は、私がそういうのだからそうするべきだ、で行ってはならない
1.3.1
ホワイトボードマーカーが切れないよう大量に購入した。思考が途切れるのを防ぐことを優先した結果である。
1.3.2
計測可能 or 計測不可能な2パターンの決定がある。
1.3.3
予期せぬコストが発生することもある。分散ビルドシステムを作ったら、エンジニアがあまり最適化をしなくなってしまった。
1.3.5
決定にその時点でのデータを活用したとしても、時間の経過で新たなデータが入ってきて、コンテキストが変化し、決定が間違いであったことがわかるということもあるだろう。決定者は必ず間違いを認める権利を有すべきで、間違いを認めることは尊敬を勝ちとりこそすれ、失うことはない。
### ソフトウェアエンジニアリング vs プログラミング
ソフトウェアエンジニアリングはプログラミングの上位に位置するなどということはない。制約、価値、ベストプラクティスが異なるというだけの話である。例えば、数日間のみ使用するプログラムにはCIや統合テストは不要である場合が多い。
プログラミングはコードを生産する即時的行動であり、ソフトウェアエンジニアリングはコードを利用しなければならない期間中に有用に保つのに必要であり、また、チームを横断した共同作業を可能にする、ポリシー、プラクティス、ツールのセットである。

## 2章 チームでうまく仕事をするには
結論:「謙虚、尊敬、信頼」とういう中心原則をめぐる自身の行動を改革することが、チームで成功するための鍵である
2.2
超有名な天才であっても、一人では成し遂げられなかっただろう。
未完成の作品を見られ、レベルの低さがバレて馬鹿にされるかもしれないという恐怖から、人は自分の作業を隠したがる。だが、仕事の隠蔽は大問題である。
2.3
単独作業に全ての時間を費やすと、不要な失敗や成長のリスクを逃す恐れがある。
2.3.1
良いアイデアを思いついたと思っても、根本的な欠陥がある可能性がある。人に見せてフィードバックをもらうことで、このリスクを減らせる。
2.3.2
バス係数。バスに轢かれることはなくても、結婚や退職など、予期せぬ事件は起こりがち。単独作業の場合、バスに轢かれるとプロジェクトは一巻の終わりである。また、複数人で作業をすると、行き詰まった時に助けてくれる。
2.3.3
なる早でフィードバックを得よ、テストせよ、セキュリティと本番環境について考慮せよ。
2.3.4
要するに隠れるな。
2.4
ソフトウェアエンジニアリングとは、チームによる取り組みである。
2.4.1
「謙虚、尊敬、信頼」が、共同作業の理想郷への辿り着くための3つの柱である。
謙虚...自己研鑽に対して開かれた存在が自分である。
尊敬...共に仕事をする他者を心から思いやる。
信頼...他者が有能で正義をなすであろうと信じ、適切な場合には他者に舵取りを任せることに異存がない
2.4.2
小さな人付き合いの構築（軽い上端を行ったり、少し親切に接する）は、十分にpayする
2.4.3.1
順応しようと見せかけるだけでも得をする。そうでなれば、ちょっとずつその代償が累積していく。
2.4.3.2
批判は相手を尊敬し、建設的なものにする。
自分という存在と、自分のコードとは別である。自分のコードを否定されたからといって、自分が否定されているわけではない。また、批判を受けた場合にも、相手を信頼し、自分のためを思ってやってくれていると認識する必要がある。フィードバックには謙虚さが必要である。質問を相手に関してではなく、自分に関するものとする工夫を凝らす。
2.4.3.3
1000万ドルという大金を失う大失敗を犯し、辞表を出そうとした重役に対し、CEO「1000万ドルのトレーニング代を払ったばかりなので、解雇はしない！」といった話。失敗は選択肢の一つなのである。失敗することがなかったとすれば、十分に革新的ではないか、十分にリスクをとっていないかのどちらかである。
2.4.4
失敗すると、適切なポストモーテム（事後分析）を行うことが重要だ。失敗を適切にドキュメントすることで、後に続く者の役に立つ。  
適切なポストモーテムは以下を含むだろう。
- 分析対象イベントの要約
- 発見から調査を経て解決に至るまでの分析対象イベントのタイムライン
- 分析対象イベントの主要原因
- 影響と損害の評価
- 問題を直ちに修正するための一連のアクションアイテム（要処理事項とそのオーナー）
- 分析対象イベントが再発するのを防ぐための一連のアクションアイテム
- 学んだ教訓
2.4.4.2
他の誰かのせいで自分の考えが変わる事は問題ない。
過ちを犯したことや、自分の力量が全然足りないことを認めると長い目で見れば自分の信望を高められる。できることのうち「わからない」と言うのが最善なこともあるのだ。
2.4.5
「Google的」であることは、以下の要素を兼ね備えていることと結論づけられた。また、以下を定義した後は、曖昧さをはらんだ「Google的」は使われなくなった。
**曖昧さの中にあっても成功する**
環境が絶えず変化している最中であっても、互いに競合する複数のメッセージや複数の方針に対処でき、合意を形成でき、問題に対して進捗を遂げることができる
**フィードバックを尊重する**
フィードバックを率直に受け、かつ与えるという両方を行える謙虚さを持ち、フィードバックの重要性を理解している
**現状に立ち向かう**
他者からの抵抗や惰性があろうと、野心的なゴールを設定し追求することができる
**ユーザを第一におく**
Google製品のユーザへの共感と尊敬に満ち、ユーザの利益を第一に考えた行動を取る
**チームを思いやる**
同僚に共感と尊敬を持ち、頼まれなくても積極的に手伝い、チームの団結力を強める
**正義をなす**
行うこと全てに強い倫理的感覚を持つ。チームと製品の誠実さを守るためなら、こんなんで不都合な決断を行うことも厭わない。
## 3章 知識共有
学びの文化は非常に大切で、それによって専門家の知識を流通することができる
3.1
学びを阻む課題として挙げられるのが、
**心理的安全性の欠如**
**情報の孤島群**
互いにコミュニケーションがなかったり、共有リソースを利用しない組織のさまざまな部分で起きる知識の断片化
**情報の断片化**
**情報の重複**
**情報のスキュー**
**単一障害点**
バス係数に関係する。善意からも発生しうる。
**全か無かの専門知識**
全てを知るものと全く知らないものに分かれた組織。専門家が自分で全てをやろうとして、新たな専門家の育成に時間をかけない場合に起こることが多い。初心者は自力でなんとかすることになり、立ち上がりの速度が低下する。
**猿真似**
理解せずに物真似すること
**幽霊の出る墓場**
コード内にあることが多い、触ったら（システム全体に影響を出す）バグが出る可能性があるから皆が避ける場所
3.2
組織の成功は、組織が擁する人々の育成と、その人々への投資にかかっている。
ドキュメント化された知識はスケーラブルで、人数が増えても問題がないが、トレードオフとして、ドキュメント化された知識は一般的になるので、専門家との一対一のアドバイス良いは適用できる度合いが低いかもしれない。また、情報を最新のものに保つための保守コストもかかる。
組織慣習的（tribal）な知識は個々のチームメンバーとドキュメント化された知識の間隙にある。
3.3
心理的安全性こそが、学びのための最も重要なものである。物事を試せることと、失敗しても安全であると感じられることである。
3.3.1
メンター制度は、メンティーが他にアドバイスを求めるものを知らない場合に話しかけるためのセーフティネットとなっている。健全な組織では、チームメイトは質問に答えてくれるというだけでなく、質問を尋ねること、知らないことを表明すること、そして、互いから学ぶことに関しても寛容なのである。
3.3.2
質問に答える時に、「えっと、実はね」はやめる。知識を鼻にかけたような訂正だからだ。
3.4
**常に学び続けよ、常に質問し続けよ** これが3章で最も重要な部分。
ヌーグラーは立ち上がりに6ヶ月はかかる
シニアであることを誤って、なんでも知っていることと同一視しないこと。リーダが公然と質問したり、知識を書いている部分を表に出したりすると、それにつづいても問題ないのだと他者は励まされる。
質問を受ける側には忍耐と親切さが求められる。
3.4.2
コードを変更する際は、文脈と目的を理解してから自分の変更が依然として妥当かを考える。妥当なら変更すれば良いし、妥当でないなら、そう考える根拠を将来の読者のためにドキュメント化する
3.5
一対一の議論から何かを学んだら、それを未来の自分のために書き留めておこう＆未来の新人のために共有しよう。
3.6
自分の知識を共有する方法として、オフィスアワー、テックトークと講習、ドキュメンテーション、コードがある。
3.7
知識を共有する文化にとって重要なもの
**尊敬**
専門知識があるけど嫌なやつというのはいらない（嫌なやつ無用）。リーダというものは、周囲の資質を引き上げ、心理的安全性を向上させるものだ。嫌なやつは良きリーダーではない。
3.7.1.2
組織の制度レベルで知識の共有を表彰し、褒賞を与えるべき
Googleにおいてはピアボーナスやクードスがあり、知識共有をした者はボーナスが与えられ、また、同僚からも認められる
3.7.2
中央集権的でカノニカルな情報源の作成と保守はコストが高く時間がかかるものの、組織全体が対象となり、需要の高い知識を伝搬しやすい。更新されていないことに気づいても、その人が専門知識を持っていない可能性が高いため、オーナーを決定するのが重要である。
開発者ガイド、goリンク（Google社内のurl短縮ツール）、google codelabによる実践的なドキュメント、静的解析などが利用される
3.8 リーダビリティ
Googleではreadabilityは単に読みやすさだけを意味しない。Googleの全社的にプログラミング言語のベストプラクティスを普及するための標準的なメンター制度となっている。現在、Googleのエンジニアの20%がレビュワーおよびコード作者としてリーダビリティプロセスに参加している。
3.8.1
リーダビリティプロセスはリーダビリティ認定を持っている人によって行われ、対象はすべてのCL(Change Line)である。すべてのCLは認定された人によって承認される必要がある。最初コメントを受けることが多かったエンジニアは、だんだんと少なくなっていき、最終的に「リーダビリティがある」と認められる。
3.8.2
リーダビリティプロセスはベストプラクティスを強制と同時に伝搬させるメカニズムであるが、エンジニアの時間を無駄にしているという意見もある。EPR（エンジニア生産性研究）チームの調査で、リーダビリティはエンジニアリングの速度に対し、総じて良い影響を与えることが示された。
## 4章 公正のためのエンジニアリング
多様性について議論していく。正解を見出せていないばかりか、Googleは弱者と見なされるユーザを守れなかった多くの過去の失敗があるが、むしろそのために本章を書き進める。
4.1
バイアスは誰にでも、無意識に存在している。
Googleは白人またはアジア人の男性が非常に多く、低代表（=弱者とみなされる要素を持った集団。女性や少数民族など）グループを十分に考慮できないことが多かった。低代表、弱者のユーザを理解するためのダイバーシティがGoogleに備わっていない場合が多いということだ。
例えば、AIが黒人をゴリラと認識してしまうという有名な事例などがある。技術自体は悪いものではない。Googleのエンジニアも非の打ちどころのない教育、専門的経験を経てきた技術者だ。対処法として、ソフトウェアエンジニアリング組織自体が、Googleが開発する製品の対象である母集団に似通っていくように促す、ということを挙げる。（少数民族や女性を優先的に採用、昇進させたりするのも一種の差別であるという意見もありそうではあるが...）
4.2
卓越したエンジニアには、製品の設計実装に多様な観点を持ち込む必要がある。多様性のかけたエンジニアリングチームになっている場合、全ユーザに向けて開発する方法をここのエンジニアが学んでいかなければならない。
4.3
エンジニアには技術面での才能を有することを期待されるが、同時に、何かを開発すべき時、そうでない時を知る識別力も有している必要がある。自分が手がける製品に、自分が思っている以上の影響力を社会にもたらす可能性があることを考慮するべきだ。その最初のステップとして、自身の持つ偏見を認識する必要がある。
4.5
多様な人種を採用するには採用経路を改めれば良いだけ、という一本槍の思考は良くなくて、採用後に低代表グループの人々が働きやすいかなど、さまざまな観点を考慮する必要がある
4.6
すでに確立されたプロセスも不当な結果を推進するものがないか疑う必要がある
## 5章 チームリーダー入門
Googleには2種類の異なるリーダーがいる。一つはマネージャーで、人員のリーダとして役割を果たす。もう一方は、テックリードであり、技術的取り組みをリードする。テックリードとマネージャーを同時にこなす、テックリードマネージャーがいることもある。
 5.1
**エンジニアリングマネージャー**
Googleは早い段階で、エンジニアリングのバックグラウンドを持つ人をマネージャーに据えることを決定した。チームが担当する製品がビジネス要件を満たすことを保証しつつ、その上でテックリードを含むチーム内の全ての人員の成績、生産性、満足度について責任を持つ。
**テックリード（TL）**
製品の技術的側面を担当し、技術的な決定と選択、アーキテクチャー、優先度、開発速度、プロジェクト管理一般を担う。大半のTLはICでもあるので、自身で何かを手っ取り早くやってしまうか、それをチームメンバーに任せて（場合によっては）より時間をかけて行わせるかのどちらかの選択を強いられる。チームの規模と力量が上がるにつれ、ほとんどの場合に後者がTLにとっての正しい選択となる。
**テックリードマネージャー（TLM）**
初期段階の小規模チームではTLMがいるのがデフォルトである場合が多い。チームでの人員面と技術面の両方の要求に対処できる1人の人物である。比較的シニアなものがTLMであることもあるが、通常は、最近までICだった者がこの役職を務めている。Googleでは基本的にTLMは採用せず、二人でやっていることが多い（両方の業務を同時にうまくこなすのは本当に難しいため）
5.2
気づいたらリーダーになっていた、というのはあるあるらしい。たとえ絶対にマネージャーにはなるまいと自分に誓っていたとしても、起こりうる。
5.2.1
エンジニアがマネージャーになることを避ける理由として、
- 仕事が定量的でないため、今日はこれだけコードを書いたぞ、というのがない。マネジメント業務が忙しい日には、「今日は全く何もやらなかったな」と思っているのに気づくだろう。
- 「ピーターの原理」（階層制度の中では、どの従業員もその従業員が無能とみなされるレベルまでは昇進する傾向がある）。Googleは昇進前に、そのレベルの職務レベルをこなすように要求することで回避している。
マネージャになる理由として、
- 自分自身をスケールさせることができる。自分のリーダーシップのもとで、素晴らしいエンジニアたちのチームがどれだけの量のコードを書けるか想像してみてほしい。
- もしかしたら得意かもしれない。
5.2.2
なんでも管理しようとするのは良くない結果に終わる可能性がある。この対処法として、サーバントリーダーシップがある。サーバントリーダシップは執事や家令のように業務を行うこと（チームメンバーが自分自身で取り除けないものの除去や、合意形成の手伝い、オフィスでチームが遅くまで仕事をしている時に夕食を買ってくる等）である。必要時にはアドバイスを行なったり、自ら手を動かすことを厭わない。
5.3 エンジニアリングマネージャー
労働者を、荷車の御者がラバを扱うのと同様に扱っていたマネージャーは過去の話であり、時代錯誤的である（今でもやっているところはあるが...）
組み立てラインの労働者と違い、ソフトウェアエンジニアは新チームでの業務についていける一人前の戦力になるのに何ヶ月もかかる場合がある。
マネージャーと従業員の関係は親と子の関係ではない。
本章で最も大切なことは↓
**伝統的なマネージャーは物事をやり遂げる方法を気にする一方で、優れたマネージャーはどんな物事かやり遂げられるのかを気にする（やる方法はチームに任せる）**
5.4 アンチパターン
**推しに弱い者を採用する**
むしろ、あなたより賢くて交代できる者を採用するべき。時に反対意見を言うこともあるだろうが、それは良いことである。
**成績の悪い者を無視する**
期待に達しない人はいる。最も難しい場合には、職務遂行能力が全くない者もいる。成績の悪い者を無視（対処しない）すると、どうなるか。それは、現在いる成績の良い者にチームをさるよう促す行いでもある。最終的には、全員成績の悪いチームになるのが落ち。
成績の悪い者をチームに留めておくことは、成績の悪い者に対してなんの思いやりにもなっていない。成績の悪い者が他のチームに移って、大きな影響力を実際に発揮する可能性が往々にしてあるからだ。
成績の悪い者は生産性が高まった状態に移るために激励や方向付けを必要としているだけだったりする。それを放置するとその者とチームの関係が拗れる可能性がある。
成績の悪い者を効果的に指導する方法として、成績の悪い者に特定の期間と達成を期待される非常に具体的なゴールを設定する。ゴールは小さく、インクリメンタルで、計測的にするべきだ。
**人間的問題を無視する**
**全員の友人になる**
全員の友人になろうと振る舞う必要はない。あなたがキャリアに関わる権限を持っているなら、相手はプレッシャーを感じているかもしれない。
**採用基準で妥協する**
定員を満たすように採用をするかもしれないが、それでも、基準に満たないものは切っておくべし
**自分のチームを子供のように扱う**
信頼できる人間を集めるべし。
5.5 建設的パターン
**エゴを捨てる**
自分のエゴを捨て、代わりに、集団的なチームとしてのエゴと主体性を育成、強化すべき。ゴールへの道はあなたではなく、チームで決定する。すべてをうまくやるという重圧を捨て、失敗した時にはごめんなさいをするべき。
5.5.2
平静を保つ。マネージャーの歯車が回れば、多くのICの歯車に影響が出る。
5.5.3
触媒となり、合意形成を助ける
5.5.4
チームが障害にぶつかって停滞してしまった時は助け舟を出そう。適切な人を紹介できるかもしれない。適切な人物を知っているというのは、多くの場合、正しい答えを知っていることよりも価値がある。
5.5.5
先生かつ、メンターになれ。メンターに必要なものは、1. チームのプロセスとシステムについての経験、2. 他者に物事を説明する能力、3. メンティーがどれだけ助けを必要としているか推し量る能力。特に3つ目が大事
5.5.6
明確なゴールを設定する。簡潔なミッションステートメントを作ることでチームメンバーのリソースを効率的に扱うことができる。
5.5.7
情報共有できないことを聞かれたら、知っているが言えないといい。知らないことを聞かれたら素直に知らないというべき。
Googleでは推奨されていないこととして、多くのマネジメントの教科書に書いてある、厳しいフィードバックを与える時には「褒め言葉のサンドイッチ」を使うというアドバイスがある。
直接的で明確なフィードバックと方向付けをしてあげる。悪意があると思われないため、伝え方は鍵になる。多少のユーモアを交えることで、悪意がないことを表現できるかもしれない。
5.5.8
チームの満足度を追跡調査するための簡単で優れた方法は、毎回の1:1面談の最後にチームメンバーに「何が必要かな」を尋ねること
5.7
秘訣集
- チームを混沌から守る
- チームの上空援護をする（上からの情報で重要なものは伝える）
- 元に戻すのが簡単なことは「イエス」を出していいが、10年くらい保守しなければいけない機能などはよく考えるべし