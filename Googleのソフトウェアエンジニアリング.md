## １章 ソフトウェアエンジニアリングとは何か

### 時間
ソフトウェアエンジニアリングにおいて、ソフトウェアの持続可能性は重要。変化に対応できるようにするべきだ。
最初のアップデートを切る抜けるだけでなく、その後も最新版に追随できる状態にすることがプロジェクトの長期的持続可能性の真髄である。
**Hyrumの法則**
あるAPIに十分な数のユーザーがいるとき、APIを作った者自身が契約仕様としてなにを約束しているかは重要ではない。 **作られたシステムがもつあらゆる観察可能(observable)な挙動に関して、それに依存するユーザーが出てくるものである**。
そこに少しでも複雑さがあれば、将来的に挙動が変わる可能性がある。そして、Hyrumの法則によってその影響を受けるユーザはいるはず。脆い、未公開の機能に依存したコードは、クレバーと言われるが、クレバーが褒め言葉で使われるならそれは「プログラミング」で、悪口で使われるなら「ソフトウェアエンジニアリング」である。
変化それ自体のために変化するべきではないが、変化の能力は備えていなければならない。
### スケール
基本的に複数人で行うので、人数が増えてもうまくスケールし、効率性を落とさないことが重要だ
人件費、計算リソース、そしてコードベースもスケールする必要がある。全体ビルド一回の時間やプログラミング言語のアップデートに対するコストは気づかないうちに大きくなっていく
1.2.1
チャーンルールは、専門家が自分自身で顧客を新バージョンに移行させるか、システムを止めずに後方互換性のある形のどちらかにしなければならないというルール。これは割とスケールする。全顧客に対応法を考えてもらうより、専門家グループを作る方がさっさと終わる。
知識はウイルスのような拡散性がある
1.2.2
Beyonceルール ... テストで検知できない問題はインフラチームの責任ではない。（テストを書いておけばよかったのに）
1.2.3
Googleは2006年のコンパイラのアップデートに非常に苦労した。BeyonceルールもCIシステムも浸透しておらず、リグレッションを出しても責められないという確信を持つことが難しかった。->Googleはスケーリングの問題を克服し、長所に変えるべく、自動化、統合/一貫性、専門知識に注力し始めた。
コードベースの柔軟性に影響する要因は専門知識（アップグレードの方法を知っていること）、安定性（リリースを定期的に、頻繁にしており、リリース間での変化が少ない）、準拠性（アップグレードをすでに経ていないコードはほとんど存在しない）、馴染み深さ（アップグレードを十分に定期的に実施しているので、そのプロセスの冗長性を見出し、自動化できる）、ポリシー（Beyonceルールのようなプロセスやポリシーを有しているか）
1.2.4 左への移動
問題を早期発見するとコストが下がる
### トレードオフ
少ないメトリクス（指標）でトレードオフの判断を迫られる。選択肢は無数にあることが多い
全ての決定にはきちんとした理由を伴うべきである
決定は、私がそういうのだからそうするべきだ、で行ってはならない
1.3.1
ホワイトボードマーカーが切れないよう大量に購入した。思考が途切れるのを防ぐことを優先した結果である。
1.3.2
計測可能 or 計測不可能な2パターンの決定がある。
1.3.3
予期せぬコストが発生することもある。分散ビルドシステムを作ったら、エンジニアがあまり最適化をしなくなってしまった。
1.3.5
決定にその時点でのデータを活用したとしても、時間の経過で新たなデータが入ってきて、コンテキストが変化し、決定が間違いであったことがわかるということもあるだろう。決定者は必ず間違いを認める権利を有すべきで、間違いを認めることは尊敬を勝ちとりこそすれ、失うことはない。
### ソフトウェアエンジニアリング vs プログラミング
ソフトウェアエンジニアリングはプログラミングの上位に位置するなどということはない。制約、価値、ベストプラクティスが異なるというだけの話である。例えば、数日間のみ使用するプログラムにはCIや統合テストは不要である場合が多い。
プログラミングはコードを生産する即時的行動であり、ソフトウェアエンジニアリングはコードを利用しなければならない期間中に有用に保つのに必要であり、また、チームを横断した共同作業を可能にする、ポリシー、プラクティス、ツールのセットである。

## 2章 チームでうまく仕事をするには
結論:「謙虚、尊敬、信頼」とういう中心原則をめぐる自身の行動を改革することが、チームで成功するための鍵である 2.2
超有名な天才であっても、一人では成し遂げられなかっただろう。
未完成の作品を見られ、レベルの低さがバレて馬鹿にされるかもしれないという恐怖から、人は自分の作業を隠したがる。だが、仕事の隠蔽は大問題である。
2.3
単独作業に全ての時間を費やすと、不要な失敗や成長のリスクを逃す恐れがある。
2.3.1
良いアイデアを思いついたと思っても、根本的な欠陥がある可能性がある。人に見せてフィードバックをもらうことで、このリスクを減らせる。
2.3.2
バス係数。バスに轢かれることはなくても、結婚や退職など、予期せぬ事件は起こりがち。単独作業の場合、バスに轢かれるとプロジェクトは一巻の終わりである。また、複数人で作業をすると、行き詰まった時に助けてくれる。
2.3.3
なる早でフィードバックを得よ、テストせよ、セキュリティと本番環境について考慮せよ。
2.3.4
要するに隠れるな。
2.4
ソフトウェアエンジニアリングとは、チームによる取り組みである。
2.4.1
「謙虚、尊敬、信頼」が、共同作業の理想郷への辿り着くための3つの柱である。
謙虚...自己研鑽に対して開かれた存在が自分である。
尊敬...共に仕事をする他者を心から思いやる。
信頼...他者が有能で正義をなすであろうと信じ、適切な場合には他者に舵取りを任せることに異存がない
2.4.2
小さな人付き合いの構築（軽い冗談を言ったり、少し親切に接する）は、十分にpayする
2.4.3.1
順応しようと見せかけるだけでも得をする。そうでなれば、ちょっとずつその代償が累積していく。
2.4.3.2
批判は相手を尊敬し、建設的なものにする。
自分という存在と、自分のコードとは別である。自分のコードを否定されたからといって、自分が否定されているわけではない。また、批判を受けた場合にも、相手を信頼し、自分のためを思ってやってくれていると認識する必要がある。フィードバックには謙虚さが必要である。質問を相手に関してではなく、自分に関するものとする工夫を凝らす。
2.4.3.3
1000万ドルという大金を失う大失敗を犯し、辞表を出そうとした重役に対し、CEO「1000万ドルのトレーニング代を払ったばかりなので、解雇はしない！」といった話。失敗は選択肢の一つなのである。失敗することがなかったとすれば、十分に革新的ではないか、十分にリスクをとっていないかのどちらかである。
2.4.4
失敗すると、適切なポストモーテム（事後分析）を行うことが重要だ。失敗を適切にドキュメントすることで、後に続く者の役に立つ。  
適切なポストモーテムは以下を含むだろう。
- 分析対象イベントの要約
- 発見から調査を経て解決に至るまでの分析対象イベントのタイムライン
- 分析対象イベントの主要原因
- 影響と損害の評価
- 問題を直ちに修正するための一連のアクションアイテム（要処理事項とそのオーナー）
- 分析対象イベントが再発するのを防ぐための一連のアクションアイテム
- 学んだ教訓
2.4.4.2
他の誰かのせいで自分の考えが変わる事は問題ない。
過ちを犯したことや、自分の力量が全然足りないことを認めると長い目で見れば自分の信望を高められる。できることのうち「わからない」と言うのが最善なこともあるのだ。
2.4.5
「Google的」であることは、以下の要素を兼ね備えていることと結論づけられた。また、以下を定義した後は、曖昧さをはらんだ「Google的」は使われなくなった。
**曖昧さの中にあっても成功する**
環境が絶えず変化している最中であっても、互いに競合する複数のメッセージや複数の方針に対処でき、合意を形成でき、問題に対して進捗を遂げることができる
**フィードバックを尊重する**
フィードバックを率直に受け、かつ与えるという両方を行える謙虚さを持ち、フィードバックの重要性を理解している
**現状に立ち向かう**
他者からの抵抗や惰性があろうと、野心的なゴールを設定し追求することができる
**ユーザを第一におく**
Google製品のユーザへの共感と尊敬に満ち、ユーザの利益を第一に考えた行動を取る
**チームを思いやる**
同僚に共感と尊敬を持ち、頼まれなくても積極的に手伝い、チームの団結力を強める
**正義をなす**
行うこと全てに強い倫理的感覚を持つ。チームと製品の誠実さを守るためなら、こんなんで不都合な決断を行うことも厭わない。
## 3章 知識共有
学びの文化は非常に大切で、それによって専門家の知識を流通することができる
3.1
学びを阻む課題として挙げられるのが、
**心理的安全性の欠如**
**情報の孤島群**
互いにコミュニケーションがなかったり、共有リソースを利用しない組織のさまざまな部分で起きる知識の断片化
**情報の断片化**
**情報の重複**
**情報のスキュー**
**単一障害点**
バス係数に関係する。善意からも発生しうる。
**全か無かの専門知識**
全てを知るものと全く知らないものに分かれた組織。専門家が自分で全てをやろうとして、新たな専門家の育成に時間をかけない場合に起こることが多い。初心者は自力でなんとかすることになり、立ち上がりの速度が低下する。
**猿真似**
理解せずに物真似すること
**幽霊の出る墓場**
コード内にあることが多い、触ったら（システム全体に影響を出す）バグが出る可能性があるから皆が避ける場所
3.2
組織の成功は、組織が擁する人々の育成と、その人々への投資にかかっている。
ドキュメント化された知識はスケーラブルで、人数が増えても問題がないが、トレードオフとして、ドキュメント化された知識は一般的になるので、専門家との一対一のアドバイス良いは適用できる度合いが低いかもしれない。また、情報を最新のものに保つための保守コストもかかる。
組織慣習的（tribal）な知識は個々のチームメンバーとドキュメント化された知識の間隙にある。
3.3
心理的安全性こそが、学びのための最も重要なものである。物事を試せることと、失敗しても安全であると感じられることである。
3.3.1
メンター制度は、メンティーが他にアドバイスを求めるものを知らない場合に話しかけるためのセーフティネットとなっている。健全な組織では、チームメイトは質問に答えてくれるというだけでなく、質問を尋ねること、知らないことを表明すること、そして、互いから学ぶことに関しても寛容なのである。
3.3.2
質問に答える時に、「えっと、実はね」はやめる。知識を鼻にかけたような訂正だからだ。
3.4
**常に学び続けよ、常に質問し続けよ** これが3章で最も重要な部分。
ヌーグラーは立ち上がりに6ヶ月はかかる
シニアであることを誤って、なんでも知っていることと同一視しないこと。リーダが公然と質問したり、知識を書いている部分を表に出したりすると、それにつづいても問題ないのだと他者は励まされる。
質問を受ける側には忍耐と親切さが求められる。
3.4.2
コードを変更する際は、文脈と目的を理解してから自分の変更が依然として妥当かを考える。妥当なら変更すれば良いし、妥当でないなら、そう考える根拠を将来の読者のためにドキュメント化する
3.5
一対一の議論から何かを学んだら、それを未来の自分のために書き留めておこう＆未来の新人のために共有しよう。
3.6
自分の知識を共有する方法として、オフィスアワー、テックトークと講習、ドキュメンテーション、コードがある。
3.7
知識を共有する文化にとって重要なもの
**尊敬**
専門知識があるけど嫌なやつというのはいらない（嫌なやつ無用）。リーダというものは、周囲の資質を引き上げ、心理的安全性を向上させるものだ。嫌なやつは良きリーダーではない。
3.7.1.2
組織の制度レベルで知識の共有を表彰し、褒賞を与えるべき
Googleにおいてはピアボーナスやクードスがあり、知識共有をした者はボーナスが与えられ、また、同僚からも認められる
3.7.2
中央集権的でカノニカルな情報源の作成と保守はコストが高く時間がかかるものの、組織全体が対象となり、需要の高い知識を伝搬しやすい。更新されていないことに気づいても、その人が専門知識を持っていない可能性が高いため、オーナーを決定するのが重要である。
開発者ガイド、goリンク（Google社内のurl短縮ツール）、google codelabによる実践的なドキュメント、静的解析などが利用される
3.8 リーダビリティ
Googleではreadabilityは単に読みやすさだけを意味しない。Googleの全社的にプログラミング言語のベストプラクティスを普及するための標準的なメンター制度となっている。現在、Googleのエンジニアの20%がレビュワーおよびコード作者としてリーダビリティプロセスに参加している。
3.8.1
リーダビリティプロセスはリーダビリティ認定を持っている人によって行われ、対象はすべてのCL(Change Line)である。すべてのCLは認定された人によって承認される必要がある。最初コメントを受けることが多かったエンジニアは、だんだんと少なくなっていき、最終的に「リーダビリティがある」と認められる。
3.8.2
リーダビリティプロセスはベストプラクティスを強制と同時に伝搬させるメカニズムであるが、エンジニアの時間を無駄にしているという意見もある。EPR（エンジニア生産性研究）チームの調査で、リーダビリティはエンジニアリングの速度に対し、総じて良い影響を与えることが示された。
## 4章 公正のためのエンジニアリング
多様性について議論していく。正解を見出せていないばかりか、Googleは弱者と見なされるユーザを守れなかった多くの過去の失敗があるが、むしろそのために本章を書き進める。
4.1
バイアスは誰にでも、無意識に存在している。
Googleは白人またはアジア人の男性が非常に多く、低代表（=弱者とみなされる要素を持った集団。女性や少数民族など）グループを十分に考慮できないことが多かった。低代表、弱者のユーザを理解するためのダイバーシティがGoogleに備わっていない場合が多いということだ。
例えば、AIが黒人をゴリラと認識してしまうという有名な事例などがある。技術自体は悪いものではない。Googleのエンジニアも非の打ちどころのない教育、専門的経験を経てきた技術者だ。対処法として、ソフトウェアエンジニアリング組織自体が、Googleが開発する製品の対象である母集団に似通っていくように促す、ということを挙げる。（少数民族や女性を優先的に採用、昇進させたりするのも一種の差別であるという意見もありそうではあるが...）
4.2
卓越したエンジニアには、製品の設計実装に多様な観点を持ち込む必要がある。多様性のかけたエンジニアリングチームになっている場合、全ユーザに向けて開発する方法をここのエンジニアが学んでいかなければならない。
4.3
エンジニアには技術面での才能を有することを期待されるが、同時に、何かを開発すべき時、そうでない時を知る識別力も有している必要がある。自分が手がける製品に、自分が思っている以上の影響力を社会にもたらす可能性があることを考慮するべきだ。その最初のステップとして、自身の持つ偏見を認識する必要がある。
4.5
多様な人種を採用するには採用経路を改めれば良いだけ、という一本槍の思考は良くなくて、採用後に低代表グループの人々が働きやすいかなど、さまざまな観点を考慮する必要がある
4.6
すでに確立されたプロセスも不当な結果を推進するものがないか疑う必要がある
## 5章 チームリーダー入門
Googleには2種類の異なるリーダーがいる。一つはマネージャーで、人員のリーダとして役割を果たす。もう一方は、テックリードであり、技術的取り組みをリードする。テックリードとマネージャーを同時にこなす、テックリードマネージャーがいることもある。
 5.1
**エンジニアリングマネージャー**
Googleは早い段階で、エンジニアリングのバックグラウンドを持つ人をマネージャーに据えることを決定した。チームが担当する製品がビジネス要件を満たすことを保証しつつ、その上でテックリードを含むチーム内の全ての人員の成績、生産性、満足度について責任を持つ。
**テックリード（TL）**
製品の技術的側面を担当し、技術的な決定と選択、アーキテクチャー、優先度、開発速度、プロジェクト管理一般を担う。大半のTLはICでもあるので、自身で何かを手っ取り早くやってしまうか、それをチームメンバーに任せて（場合によっては）より時間をかけて行わせるかのどちらかの選択を強いられる。チームの規模と力量が上がるにつれ、ほとんどの場合に後者がTLにとっての正しい選択となる。
**テックリードマネージャー（TLM）**
初期段階の小規模チームではTLMがいるのがデフォルトである場合が多い。チームでの人員面と技術面の両方の要求に対処できる1人の人物である。比較的シニアなものがTLMであることもあるが、通常は、最近までICだった者がこの役職を務めている。Googleでは基本的にTLMは採用せず、二人でやっていることが多い（両方の業務を同時にうまくこなすのは本当に難しいため）
5.2
気づいたらリーダーになっていた、というのはあるあるらしい。たとえ絶対にマネージャーにはなるまいと自分に誓っていたとしても、起こりうる。
5.2.1
エンジニアがマネージャーになることを避ける理由として、
- 仕事が定量的でないため、今日はこれだけコードを書いたぞ、というのがない。マネジメント業務が忙しい日には、「今日は全く何もやらなかったな」と思っているのに気づくだろう。
- 「ピーターの原理」（階層制度の中では、どの従業員もその従業員が無能とみなされるレベルまでは昇進する傾向がある）。Googleは昇進前に、そのレベルの職務レベルをこなすように要求することで回避している。
マネージャになる理由として、
- 自分自身をスケールさせることができる。自分のリーダーシップのもとで、素晴らしいエンジニアたちのチームがどれだけの量のコードを書けるか想像してみてほしい。
- もしかしたら得意かもしれない。
5.2.2
なんでも管理しようとするのは良くない結果に終わる可能性がある。この対処法として、サーバントリーダーシップがある。サーバントリーダシップは執事や家令のように業務を行うこと（チームメンバーが自分自身で取り除けないものの除去や、合意形成の手伝い、オフィスでチームが遅くまで仕事をしている時に夕食を買ってくる等）である。必要時にはアドバイスを行なったり、自ら手を動かすことを厭わない。
5.3 エンジニアリングマネージャー
労働者を、荷車の御者がラバを扱うのと同様に扱っていたマネージャーは過去の話であり、時代錯誤的である（今でもやっているところはあるが...）
組み立てラインの労働者と違い、ソフトウェアエンジニアは新チームでの業務についていける一人前の戦力になるのに何ヶ月もかかる場合がある。
マネージャーと従業員の関係は親と子の関係ではない。
本章で最も大切なことは↓
**伝統的なマネージャーは物事をやり遂げる方法を気にする一方で、優れたマネージャーはどんな物事かやり遂げられるのかを気にする（やる方法はチームに任せる）**
5.4 アンチパターン
**推しに弱い者を採用する**
むしろ、あなたより賢くて交代できる者を採用するべき。時に反対意見を言うこともあるだろうが、それは良いことである。
**成績の悪い者を無視する**
期待に達しない人はいる。最も難しい場合には、職務遂行能力が全くない者もいる。成績の悪い者を無視（対処しない）すると、どうなるか。それは、現在いる成績の良い者にチームをさるよう促す行いでもある。最終的には、全員成績の悪いチームになるのが落ち。
成績の悪い者をチームに留めておくことは、成績の悪い者に対してなんの思いやりにもなっていない。成績の悪い者が他のチームに移って、大きな影響力を実際に発揮する可能性が往々にしてあるからだ。
成績の悪い者は生産性が高まった状態に移るために激励や方向付けを必要としているだけだったりする。それを放置するとその者とチームの関係が拗れる可能性がある。
成績の悪い者を効果的に指導する方法として、成績の悪い者に特定の期間と達成を期待される非常に具体的なゴールを設定する。ゴールは小さく、インクリメンタルで、計測的にするべきだ。
**人間的問題を無視する**
**全員の友人になる**
全員の友人になろうと振る舞う必要はない。あなたがキャリアに関わる権限を持っているなら、相手はプレッシャーを感じているかもしれない。
**採用基準で妥協する**
定員を満たすように採用をするかもしれないが、それでも、基準に満たないものは切っておくべし
**自分のチームを子供のように扱う**
信頼できる人間を集めるべし。
5.5 建設的パターン
**エゴを捨てる**
自分のエゴを捨て、代わりに、集団的なチームとしてのエゴと主体性を育成、強化すべき。ゴールへの道はあなたではなく、チームで決定する。すべてをうまくやるという重圧を捨て、失敗した時にはごめんなさいをするべき。
5.5.2
平静を保つ。マネージャーの歯車が回れば、多くのICの歯車に影響が出る。
5.5.3
触媒となり、合意形成を助ける
5.5.4
チームが障害にぶつかって停滞してしまった時は助け舟を出そう。適切な人を紹介できるかもしれない。適切な人物を知っているというのは、多くの場合、正しい答えを知っていることよりも価値がある。
5.5.5
先生かつ、メンターになれ。メンターに必要なものは、1. チームのプロセスとシステムについての経験、2. 他者に物事を説明する能力、3. メンティーがどれだけ助けを必要としているか推し量る能力。特に3つ目が大事
5.5.6
明確なゴールを設定する。簡潔なミッションステートメントを作ることでチームメンバーのリソースを効率的に扱うことができる。
5.5.7
情報共有できないことを聞かれたら、知っているが言えないといい。知らないことを聞かれたら素直に知らないというべき。
Googleでは推奨されていないこととして、多くのマネジメントの教科書に書いてある、厳しいフィードバックを与える時には「褒め言葉のサンドイッチ」を使うというアドバイスがある。
直接的で明確なフィードバックと方向付けをしてあげる。悪意があると思われないため、伝え方は鍵になる。多少のユーモアを交えることで、悪意がないことを表現できるかもしれない。
5.5.8
チームの満足度を追跡調査するための簡単で優れた方法は、毎回の1:1面談の最後にチームメンバーに「何が必要かな」を尋ねること
5.7
秘訣集
- チームを混沌から守る
- チームの上空援護をする（上からの情報で重要なものは伝える）
- 元に戻すのが簡単なことは「イエス」を出していいが、10年くらい保守しなければいけない機能などはよく考えるべし
5.8
動機づけと方向づけが成長に必要。方向づけは正攻法だが、動機づけはちょっと精緻なところがある
動機づけには内発的と外発的があるが、内発的の方が重要。自主性、熟達、目的の3つが内発的動機を向上させられる。
自主性は、オーナーシップ意識を与えること
熟達は、エンジニアに既存のスキルを伸ばし、新たなスキルを学び機会を与えること
目的は、チームが努力する理由を提示すること。例えば、どのように顧客のビジネスを支援したかについて語っているメッセージを見つけたら、エンジニアリングチームに転送する。
## 6章 スケールするリーダー
率いるチーム数が複数になるのは自然な流れ。
真に優れたリーダーへ自分をスケールさせるには、「3つのいつでも」が鍵となる
6.1 いつでも決断せよ
曖昧な問題の解決方針決定のプロセスは、目隠しを特定、トレードオフを特定、最後に決定を行い、解法を反復する
目隠し ... 経験からくる憶測のせいで頭が固くなっていること
トレードオフ ... 銀の弾丸はなく、現時点で最良の答えを選ぶため、トレードオフ群を指摘し、それを皆に説明し、どのようなバランスを取るかという決定を補助するのがあなたの役目
決定を反復 ... 次の月には状況が変わるかもしれないので、トレードオフ群を再評価し、バランスを再調整する。
6.2 いつでも立ち去れ
自分がSPOFにならないために注意が必要である。
6.2.1 「自動運転」チームを構築する
複数のチームをまとめて率いることは、人間たちを組織することであることが多い。
6.2.2
解決困難な問題は複数の難しい部分問題からなっていることが多い。いくつかの部分問題に分割し、各チームにそれらを担当させよう。
6.2.2.3
小さな方向づけは非常に価値のあるものだ。優れたマネジメントの95%は観察と傾聴で、5%が目指す方向に印をつけることである。
6.2.2.4
チームに担当させるのは製品ではなく問題であるべき。
6.3 いつでもスケールせよ
マネージャーとチームを率いて成功すると、報酬とともに新しい問題が舞い降りてきて、同時に解決しなければならないため、半数の人員、時間で解決を求められる（圧縮ステージ）
問題を圧縮する行為は自チームの効率化だけでなく、自分の時間と注意力を新しい責任範囲に見合うようスケールさせることである
6.3.2
マネージャーになると、行動がリアクティブ（反応的）になってくる
問題には緊急なものと重要なものがある。重要なものに時間を割くには、移譲や集中する用の時間を確保しておく、todoリストなどの追跡システムを（色々試して）見つけるなどがある
6.3.3
こんまり片付け術のように、重要度の上位20%をやるようにする
6.3.4
自身のエネルギーの管理には
- メールなどのつながりを断って本物の休暇を取る
- そのために、繋がりを断ちやすいようにする（アプリ管理などiosでできるかわからないが）
- 本物の「週末休み」
- 日中にも休憩（散歩したり...）
- メンタルヘルスの日を取ることを自分に許す
## 7章　エンジニアリング生産性の計測
エンジニアの生産性それ自体に専念する専門家のチームを要することは非常に有用かつ重要
7.1
ソフトウェアエンジニアリングの生産性を改善するだけでなく、その改善を継続することがゴール
7.2
まずは**トリアージ**のプロセスから始まる
トリアージでは、生産性の計測の前に、最初に具体的な質問を用意する
**どのような計測結果を期待しているのか、またそれはなぜか**
**期待した計測値を得た場合、どんな行動を取るのか**
**否定的な計測値の場合、適切な行動がとられるか
計測結果に対して行動に出ることを決定するのは誰か、そしていつ決定するのか**
計測の成功は、決定を行うのに必要なデータを利害関係者に与えているということである。
7.3
メトリクス作成にはGSM（Goal/Signals/Metrics）フレームワークを利用する
- **ゴール**は望ましい最終結果
- **シグナル**は、最終的な結果を達成したことを知る方法だが、計測できないかもしれない
- **メトリクス**はシグナルの代用品。これは計測可能。
GSMの特徴
- 街灯効果を予防できる。（見える、計測できるところだけを探しても落とした鍵は見つからないかも）
- 実際に結果を測定する前に適切なメトリクスの組み合わせを見つけるように促すことができる
- どこが計測の対象範囲となっているか、あるいはなっていないかを示せる
**ゴール**
生産性内部のトレードオフを忘れがちなので注意して決める。
QUANTSを評価しよう。
Q ... Quality of the Code
A ... Attention from engineers （どのくらいの頻度でエンジニアがflowに入るか、通知でどのくらい気が散るか、ツールはエンジニアに頭の切り替えを促すか）
N ... Intellectual Complexity 
T ... テンポと速度
S ... Satisfaction
**シグナル**
ゴールに達していると認められる現象が起きているか。例えば、リーダビリティプロセスでベストプラクティスをエンジニアが学べることをゴールとしている場合、エンジニアがリーダビリティからの学びを報告していればゴールに達している。
シグナルおよびメトリクスはゴールに対して一つであるとは限らない。
**メトリクス**
シグナルをどう計測するかを最終的に決定する場である。メトリクスはシグナルの代替品として使用可能である。
## 8章 スタイルガイドとルール
8.1 なぜルールを設けるのか
ルールを設けることで「良い」とされる行動を促すことができる。
8.2 ルールを作る
ルールを作る際に尋ねるべきは「どんなゴールを前進させようとしているのか」である。
ルールを作る時の包括的原則
**ルール側のルールと同様に有用でなければならない**
**（コードの）読者に向けて最適化せよ**
**一貫性を保て** ... どのオフィスも同じように働けるように. これで, より効率的に働けるようになる
**誤りの起きやすく意外な構文は避けよ**
**現実問題に譲歩せよ** ... 例外も認める
スタイルガイドには
**危険を避ける** ... バグが入り込みにくく、保守性のある言語利用を推奨
**ベストプラクティスを強制する**
**一貫性を組み込む** ... 延々続く議論はせず、決定を行うことが重要
8.3
状況が変わってきて、ルールを変更することはあり得る
変更の必要性は大体それを書いているエンジニアが最初に気づき、スタイルガイド関連議論専用の言語特有メーリングリストから始め、質問するか変更を提案できる。
8.3.2
スタイルガイドについての最終決定はスタイルガイドオーナーであるスタイル調停者によって行われる
8.3.3
例外については、調停者にルール適用の免除を求めることができる（ただし、認められないことも多い）。また、ルールを違反するのが違反を回避するよりも有益だと判断される場合、例外は許容される
8.4
ガイダンスが対象とするのは間違いやすいこと、混乱に陥りやすいこと。ルールが「絶対にやらなければならないこと」だとしたら、ガイダンスは「やるべきこと」である。
8.5
ルールは教育とトレーニングを通じて、人々の間で社会的に守らせることも可能だし、技術的にはツールで守らせることもできる。
8.5.1
エラーチェッカーを導入することで、ルール遵守のコストを下げることができる
8.5.2
gofmtなどのコードフォーマッターも同様である
## 9章 コードレビュー
コードレビューは基本的にプロセスとツールの二つが必要。
基本フローは、変更->レビュー依頼->フィードバック->修正->同じ人に再度レビュー依頼->LGMT
9.2
コードレビューでは、
- コードが適切で作者が主張する通りの動作をするという正しさの確認
- コードが、コードベースのその特定の部分に対して適切であるというもの
- リーダビリティを持つものによる、ベストプラクティスに従っていることの承認
の3つの側面がある
9.3 
コードレビューを行うことで確かに任意のコード変更が本番環境に出るまでの時間に影響を与えるが、レビュープロセスとコードレビューを真摯に受け止める文化は以下のようなメリットをもたらす。
- コードの正しさをチェックする ... コードが意図通りに動くか、バグを孕んでいないかをチェック。バグは早めに見つかった方が結果的に短い時間で済む
- コードの変更が、他のエンジニアにとって意味を把握できる物であることを保証する ... コードは複数人から読まれる物なので、他の人が理解可能かどうかをチェックする
- コードベース全体での一貫性を強制する ... コードがベストプラクティスに従っており、過度に複雑になっていないかを、その言語のリーダビリティのあるエンジニアからの承認を要する
- チームのオーナーシップを心理的に促進する ... コードが自分個人のものではなく、チームのものであるという認識を強化する。また、コードレビュープロセス自体が批判的なレビューを要求するものなので、レビュアーもレビュイーも心を傷つけにくい。
- 知識共有を可能にする
- コードレビュー自体の履歴の記録を提供する
9.4 コードレビューのベストプラクティス
9.4.1 礼儀正しく、かつプロフェッショナルになれ
レビュアーは作者の特定アプローチについて、作者を尊敬すべきであり、そのアプローチが不十分な場合にのみ代案の指摘を行うべき。
レビューを経てもアプローチに欠陥が発見された場合は、そのレビューを双方にとっての学びの機会と考える。
レビュアーは、迅速にフィードバックを行う。24時間以内が期待される。無理そうなら、なるはやでレビューしますと返信を送っておく。
コードレビューに少しずつ断片的に返信するのも良くない。
コードレビューにつけられたコメントはTODO項目として扱う。全てを受け入れる必要はないが、コメントへの対処は行うべき。
作者がレビューに同意しない場合、代案を出してレビュアーにPTAL（Please take another look）を依頼する
9.4.2 小さな変更をかけ
コードの変更は理解しやすいように小さなものであるべき。完全なプロジェクトの形をとるものが複数入っている大規模な変更についてじゃ、レビュアーは一回のレビューには大きすぎるとして正当に拒絶することができる。
「小さな変更」は約200行までのコードに限定されるべきだ。
小さな変更であれば、その日中に終わらせやすい。また、誤ったアプローチに多くの労力を注ぎ込むことも防げる。
9.4.3 良い変更説明をかけ
変更説明の一行目は超重要で、ここに要約としてその変更がどんな種類のものかを示すべきだ。最初の行では、変更全体の要約となるが、何が変更されていて、なぜ変更されるのかの詳細についても説明が必要。
9.4.4 レビュアーの人数は最小限にとどめよ
Googleではレビュアーは大体一人。別部署のエンジニアから追加的な意見を得ようとする風潮があったりするが、すぐにレビュアーを追加したことによるコストがメリットを上回る。追加のLGTMはあんまり重要ではない。
9.4.5 可能な場合は自動化せよ
テスト、リンター、フォーマッターの実行を作者に要求するのではなく、リポジトリ提出前処理として、レビュアーに送られる時に自動で処理され、その結果、多様な問題を検出したり、変更を却下したり、まず変更を修正するように元の作者に依頼したりすることができる。
9.5
Googleのコード変更は大体以下の4種類
- グリーンフィールドレビューと新機能開発 ... 全く新しいコードを追加する
- 挙動の変更、改善、最適化 ... APIの挙動が変わるならテストも修正されるべきである。最適化であればベンチマーク結果も含むべきかもしれない。
- バグ修正とロールバック ... コードの変更はバグ修正に集中し、それ以外の問題には対処するな。また、発生したエラーを捕捉できるようにテストも修正しておくべき。ロールバックするだけでもコードレビューは必要である。
- リファクタリングと大規模変更 ... 機械による変更でもコードレビューが必要。
## 10章 ドキュメンテーション
品質の高いドキュメンテーションの欠如は多くのエンジニアが抱く不満である。
また、ドキュメンテーションは多くの場合、エンジニア自身が書かなければならないだろう。Googleで最も成功せいている取り組みは、ドキュメントを**コードのように扱いつつ**、伝統的なエンジニアリングワークフローへ組み込むことだ
10.1
ドキュメンテーションにはコード内のコメントも含まれる。
10.2
ドキュメンテーションは絶大な恩恵がある。コードやAPIの意味が理解しやすくなり、間違いが減る、新メンバーへのオンボーディングの労力が減る。
ただ、ドキュメンテーションは恩恵をテストほどすぐに得られるわけではなく、特に、作者にはあまり利益がない。
グループと書き手の利益は
- APIの定式化を促す
- 保守のロードマップと履歴の記録を提供する。数年後にコードを読んで間違っている箇所を見つけようとする場合、良質なコメントがあると大いに助けになる
- コードがプロフェッショナルに見える
- 他のユーザの質問回数を減らせる
10.3
ドキュメンテーションはコードのように扱い、以下のようなものであるべき
- 内部的なポリシーかルールを持つ
- ソースコントロールシステムの管理下に置かれる
- ドキュメンテーションにはそれを保守する責任を持つ明確なオーナーシップがある
- 変更についてもレビューを経る
- コードのバグが追跡されるようにドキュメントも問題が追跡される
- 定期的に評価される
- （可能であれば）正確性や鮮度の面で計測される
10.4
ドキュメンテーションを自分のためだけに書くのは大きな間違い。代わりに、そのドキュメントの対象読者を特定するべきだ。
もっと優れたドキュメンテーションを書かないといけないと思うのは間違い。
10.4.1
ドキュメントを短く保つと対象読者を見誤るのを回避しやすい。
自分が欲しいものがわかっているエンジニアに対しては、一貫性を提供するべき。
自分が欲しいものが曖昧な人に対しては、TL;DRをつける（ドキュメントの途中に入れて、「興味のない人はここで読み進めるのをやめることができる」としてもいい）
10.5
一つのドキュメントに複数のことを詰め込んではならない。ドキュメントには必ず唯一無二の目的を持つべき。そのページに何かを追加することが合理的でない場合は、別のドキュメントを探したり、新規作成すると良い。
10.5.1 リファレンスドキュメンテーション
リファレンスドキュメンテーションには、主にAPIコメントと、実装コメントの二種類。APIコメントはより広い範囲を読者としており、実装コメントにはより前提知識を必要とし、コードがその書き方で書かれた理由を説明する。
大半のリファレンスドキュメンテーションは、コードベース自体の中にあるコメントから生成されているべき。GoDocなどのコメント追加フレームワークもある。
10.5.1.1
ファイルコメントは、ファイルの始まりに、何が含まれているかをについての概要を書く。
10.5.1.2
クラスコメントはオブジェクトとしての特徴に重点を置き、Fooクラス、Barクラス、関数xなど、「名詞づけ」を含む
10.5.1.3
関数コメントには、何を行うかを説明する。スタイルガイドは設けず、自然な文体で書く方がわかりやすい。
10.5.2 デザインドキュメント
Googleではほとんどのチームで実作業の着工前に設計を記したデザインドキュメントの提出が求められる。これは、実装前の一種のコードレビューの役割を果たしており、さまざまな懸念点からそのドメインの専門家によりレビューされる。最も優れたドキュメントは設計のゴールを提案し、設計の各種代案を網羅して論じ、それらの代案の強み、弱みを示す。
製品のローンチ前にデザインドキュメントを再レビューし、元のゴールが存続していなければ、ドキュメントか製品のどちらかを適宜調整できる。
10.5.3 チュートリアル
大半のプロジェクトのチュートリアルは何かを実質的に起こせるような「HelloWorld」ドキュメントが用意されているべき。それを作る最もいい機会は、チームに初めて参加するときだ（すでにある時は、それがチュートリアル内のバグの発見に最も良い機会だ）。
10.5.4 概念的ドキュメンテーション
概念的ドキュメンテーションはAPIやシステムの外観を提供し、リファレンスドキュメンテーションを強化する。明確性のためにある程度正確性を犠牲にしても構わない。リファレンスドキュメンテースヨンとの内容の重複も明確性の強調をするために許容される。最も書くのが難しいドキュメンテーション形式で、見過ごされやすい
10.5.5 ランディングページ
ランディングページは目的を明確に特定しているようにし、さらなる情報を得るための他のページのリンク**のみ**を含めるようにする。交通整理の役割を持っていると言える。
10.6 ドキュメンテーションのレビュー
 ドキュメンテーションもレビューを要する。
 - 正確性のための技術的レビュー。大抵専門家によって行われる
 - 明確性のためのレビュー。新人やAPI利用者など、その領域に親しんでいないものによって行われる
 - 一貫性のための作文法レビュー。テクニカルライターもしくは志願者による
 10.7 ドキュメンテーション哲学
 5W1Hを意識して書くべき。Howが最も重要性が高いことが多いが、それ以外も含めるべき。
 エンジニアは冗長性を嫌うが、ドキュメンテーションにおいては冗長性が有益なことがよくある
 10.7.3
 優れたドキュメンテーションには完全生、正確性、明確性の3つの側面がある。優れたドキュメントはその意図された役目をこなしていればよく、これらの3つを同時に満たす必要はない。また、改善したい時には、対象読者から何が求められているのかを考え、それに専念すると良い
 10.7.4 ドキュメントを廃止する
 ドキュメントが古くて何の役にも立っていないなら、削除するか旧版のドキュメントとして識別すべき。ドキュメントにはしばしば鮮度日付といって、そのドキュメントのオーナーと、最終レビュー日が記録されている
 10.8 テクニカルライターはいつ必要か
 Googleはテクニカルライターが昔から不足している。テクニカルライターを重要なプロジェクトに配置したが、それは間違いで、自分たち自身のためのドキュメンテーションなら全く申し分なくかける。テクニカルライターを必要としがちなのは、他の対象読者向けにドキュメントを書いている場合だけである。
## 11章 テスト概観
テストの重要性はバグを早期に補足でき、また、変化を可能とする能力を備えることもできる。例えば、リファクタリングや新機能追加をしても自動テストは間違いを素早く補足できる。
11.1 なぜテストを書くのか
何百、あるいは何千のテストをまとめたものは**テストスイート**と呼ばれる。テストスイートの作成と保守は大変な労力が必要で、それらの対策を怠り、ダメなテストスイートになってしまっては、テストスイートが全くないよりもタチが悪い。
11.1.1
Google Web Serverは、テストがまともになかったため、最大級の被害を受けていた。TLが全ての新規変更にテストを加えるという、テストについてのポリシーを作成し、緊急の本番コードリリースの数は半減した。GWSが教えるものは、製品の欠陥を避けるのに一部の優れたエンジニアに頼るのではないということ。自動テストと手動デバッグでは、エンジニアリングリソース面でのコストに雲泥の差がある。
11.1.3
純粋なテストは書く、実行する、失敗するの3つの活動からなる。QAチームがいても、エンジニアが自分自身のために自動テストを書き、実行する。
健全なテスト文化はテストを書く作業を分担共有を皆に促し、定期的なテスト実行をし、破綻したテストは迅速に修正する。
11.1.4 コードをテストする利点
コードをテストする利点は
- デバッグの減少
- 変更への信頼の増大
- ドキュメンテーションの改善（テスト自体が実行可能なドキュメンテーションとなる）
- レビューの単純化
- 思慮に富む設計（依存関係が多く、蜜結合になっているコードはテストがかなり書きにくいため、結果的にテストを書くために優れた設計になる。）
- 高速で高品質なリリース
11.2 テストスイートを設計する
小さいテストを積み上げる方が、大きいテスト一つよりも良い。
Googleには3つの規模のテストがある。小テスト、中テスト、大テストだ。
小テストは単一のプロセスで実行され、中テストは単一のマシンで実行され、大テストは任意の好きな場所で実行される。
**小テスト**
小テストの制約はsleepできない、IO操作できない、他のあらゆるブロックする関数呼び出しができない。外部の影響を受けないようにすることで、外部要因で失敗する可能性（=非決定性）を排除できる。
**中テスト**
中テストは複数プロセスに広がることができ、localhostへのアクセスが可能。データベースのインスタンスを実行可能だったり、ウェブUIとサーバーの組み合わせのテストもできる。
**大テスト**
大テストはlocalhostだけでなく、複数のマシンにアクセスが許される。単一マシンでの実行に比べ、速度低下と非決定性を招く可能性が著しく増すことに注意。
（Googleでは、非決定性のある信頼不能テストはおよそ0.15%らしい）
11.2.1.4
テストは密閉されているべきで、外部環境についての前提条件はあまり持つべきではない。また、テストコードはシンプルにすべきで、テストコード内でif文やループは非推奨である。
11.2.2
テスト範囲は小さくするべき。ここでの範囲は実行されるコードではなく、検証されるコードである。Googleで目指しているのは大雑把にユニットテスト80%, インテグレーションテスト15%, エンドツーエンド5%くらいだ。とはいえ、読者の状況に応じて異なるバランスが望ましくなるだろう。
11.2.3
テストは破綻したら困るもの全てに用意しておくべきだ。Beyonceルールは、「そんなに好きならそいつにテストつけとけばよかったのに」を意味する。
11.2.4
コードカバレッジはコードで実行されるコードの行の割合を示しているだけで、それで適切にテストされているかはわからない。
11.3
Googleほどの規模だと、テストの書き方が下手だと数行の変更で何十個ものテストが落ちる。また、モックオブジェクトの誤った利用で酷い害を被ったこともある。さらに、テストにかかる時間も多くなる。並列化で高速化を図ることもできるが、ものすごく遅い単一のテストがあればそこがボトルネックとなり得る。
テストが遅く、非決定的だと、テストをすっ飛ばすエンジニアが現れる。
11.4 Googleのテストの歴史
Googleに自動テストの分化を根づけた要因として、オリエンテーション講習、テスト認定プログラム、トイレでのテストの3つが挙げられる。
11.4.1 オリエンテーション講習
社員がテストをあまり書いていないとしても、新しく入ってくる新人にさもテストを書くのが当たり前のように教えることで、トロイの木馬的にテスト分化を導入した。
11.4.2 テスト認定プログラム
テスト認定プログラムはプロジェクトのテストの成熟度を5段階で評価、改善方法を提示するといったもので、これにより各チームは互いに競い合ってテストのレベルを上げようとするようになった。
11.4.3 トイレでのテスト
トイレの個室にPythonでのテストを改善する方法を扱う短い記事を貼ったことで、全社的にテストの意識が高まった。
11.4.4 今日のテスト文化
オリエンテーション講習もトイレでのテストも続いている。テスト認定プログラムはその代替としてProject Healthというツールを最近ローンチした。それは、プロジェクトの健全性を評価するもので、1（最悪）から5（最良）までの5段階評価だ。
11.5 自動テストの限界
自動テストではなく、人間がやった方が良いものもある。例えば、実際に検索クエリーを利用して受けた印象を記録してもらうなど。また、複雑なセキュリティ脆弱性の探索は、人間の方が自動システムより上手い。
## 12章 ユニットテスト
ユニットテストは、単一のクラスまたはメソッドのような相対的に狭い範囲のテストを指す。以下のような特徴を持つ
- 規模が小さいので、実行が容易かつフィードバックを直ちに得られる。
- テスト対象のコードと同時に書くのが容易。
- 素早く簡単に描けるので、テストカバレッジが高水準となる傾向がある。
- テスト対象が小さいことがほとんどなので、失敗した時に何が間違っていたかを理解しやすい
- ドキュメンテーションやコード例にもなる
12.1 保守性の重要さ
ここでの保守性は「とにかく動作する」を意味する。保守性がない（つまり、脆い）テストがあると、無関係な部分の変更でもテストが破綻する可能性があり、このようなテストは生産性にとって逆効果である。
12.2.1 変化しないテストを目指す
理想のテストは変化しないテストだ。以下は主要な変更とテストの関係性だ。
- 純粋なリファクタリング
この変更でテストが落ちるということは、純粋なリファクタリングではないか、適切な抽象化レベルではなかったということを意味する
- 新機能
この変更でテストで落ちるということは新機能が何か意図しない結果を産んだか、テストが不適切だ
- バグ修正
テストケースが抜けていたということなので、追加しよう
- 挙動の変更
唯一テストケースの更新が必要な変更。
12.2.2 公開API経由のテスト
privateを外してテストをするのは良くない。公開APIのみを利用するテストであれば、そのシステムのユーザーがアクセスするのと同じやり方でアクセスできる。そうなると、テストが壊れるのはユーザーにも影響が出ることになるので、破綻しにくくなる。
メソッドまたはクラスが1つか2つの別のクラスを支援するためだけに使われる存在なら、それ自体はユニットと見做されるべきではない。パッケージまたはクラスがそのオーナーに相談不要で誰でもアクセスできるなら、それはテストされるべきユニットである。サポートライブラリ的なものもテストされるべき。
12.2.3
テスト対象のシステムが期待通りの動きを行うかどうかは、そのシステム自体の状態を観察するステートテストと、期待される一連の動作を強調動作の対象に対して行なったかどうかをチェックするインストラクションテストがある。インストラクションテストがどのように行うかに対し、ステートテストは結果が何かに注目するので、後者の方が保守性がある。
モックオブジェクトを使ったテストは、そのモック対象を呼び出し後にそれを打ち消すような処理が間違えて入っていてもテストをパスする。テスト対象の実行後に結果を確認した方が良い。また、高速で決定制であれば、モックオブジェクトではなく、本物のオブジェクトを使った方が良い。
12.3 明確なテストを書く
テストはどれだけ脆さを回避して書いてもいずれ失敗する（これは良いこと）。その時、問題はテスト対象コードなのかテストコード自体なのかの二通りで、どちらなのかを素早く判断するためにはテストの明確性が不可欠。明確性のないテストは消されることになるかもしれないし、全く意味をなしてないことが後からわかるかもしれない。
12.3.1 テストは完全かつ簡潔にせよ
そのテストがどのようにその結果に到達するか読者が理解するのに必要な情報が全て入っていれば**完全**、また、無関係な情報が含まれていなければ**簡潔**と言える
12.3.2 メソッドではなく、挙動をテストせよ
全てのメソッドにテストを書くのは最初は役に立つかもしれないが、時間の経過とともに複雑になり、問題が起きる。メソッドに機能が追加されるとその分一つのテストで検証する項目が増えてしまい、何をやっているか分かりにくくなるからだ。同じメソッドであっても挙動が複数なら挙動ごとにテストを分けて書こう。
12.3.2.1 挙動を強調するようにテストを構成せよ
うまくコメントを使って前提条件、〜の場合、〜すべきでテスト内を分割する
// Aが30ドル持っている条件下で
// AがBに20ドル送金する場合
// 最新の口座残高は送金結果を反映するべきである
自明なテストであれば省略可能。
読者はまず、テストのメソッド名からテストされる挙動の大雑把な説明を得る。それで十分でない場合に以上のコメントを読み、最後にコードを読む。
場合とすべきを交互に入れているテストはこの書き方に違反している。
12.3.2.2 テストされる挙動にちなんでテストを命名せよ
test_UpdateBalance みたいなテスト名はあまり良くない。長くなってもいいので、挙動を関数名に入れるべき。長くなってもいいのは、テストコードが他のコードで呼び出されることはほとんどないため。逆に、読むことは多いので、分かりやすくするのに冗長性を入れても良い。
12.3.3 テストにロジックを入れるな
バグを明確化するためにちょっとした加算演算でも入れるべきではない。
12.3.4 明確な失敗メッセージを書け
Trueを期待したが、Falseだったといったエラーメッセージは分かりにくい。
例えば、Goであればこのようにエラーメッセージを書くのが慣例的。
t.Errorf("Add(2, 3) = %v, 期待されるのは %v", result, 5)
12.3 テストとコード共有: DRY ではなく DAMP
テストは本番向けコードよりもDRYの恩恵を得ずらい。DRYではなく、DAMP（Descriptive And Meaningful Phrases）が奨励される。関数に括り出してDRYを達成しても、ファイルの全然別の部分にスクロールしなければ読者が見ることのできないヘルパーメソッドに重要な詳細が隠されていると、ぱっと見でテストのバグを見つけづらい。
12.4.1 共有値
ACCOUT_1, ACCOUNT_2のような共有値は具体的にどのような役割でなんの値が入っているかわかりにくい。ACCOUNT_WITH_LOW_BALANCEは多少はマシになる。もっとも良いのはヘルパーメソッドを用いた共有値である。
PHPで書いてみるとこんな感じ。
```
function newContact(firstName = "Grace", secondName="Hopper", phoneNumber="555-123-4567") 
{
	return new Contact(firstName, secondName, phoneNumber)
}
// 呼び出し元では名前付き引数で
newContact(firstName: "Yamada", secondName: "Taro")
```
JavaとかGoならビルダーを作る。
```
contact := NewContactBuilder().FirstName("Yamada").SecondName("Taro")
```
12.4.2 初期設定の共有
ほとんどのテストフレームワークではテスト実行前に実行するメソッド(setupメソッド)を定義できる。上手く使えば繰り返しを除去し、テストをより明確かつ簡潔にできる一方、初期化メソッド内に重要な情報を隠してしまう可能性がある。
```
@Before
public void SetUp() {
	nameService = new NameService();
	nameService.set("user1", "Donald Knuth");
	userStore = new UserStore(nameService);
}
////
@Test
public void ShouldReturnNameFromService() {
	userDetails user = userStore.get("user1");
	// ↓この関数だけ読むといきなりDonald Knuthが出てきてびっくりする
	assertThat(user.getName()).isEqualTo("Donald Knuth");
}
```
12.4.4 テストインフラストラクチャーを定義する
テストインフラストラクチャーを注意深く設計すればユニットテストが書きやすくなる。テストインフラストラクチャーのコードは呼び出し元が多く、テストを壊さず変更するのが難しくなる可能性があるので注意。また、テストインフラストラクチャー自体にもテストが必要不可欠。なお、大多数のエンジニアはJunitなどの有名なサードパーティのライブラリーという形態で提供されている。
## 13章 テストダブル
テストダブルはしばしばモッキングと呼ばれるもの。メモリ内データベースもテストダブルのわかりやすい類型。テストダブルは本物の実装よりもずっと軽量なので、たくさんの小テストを迅速に実行可能になる。
13.1 テストダブルのソフトウェア開発への影響
**テスト可能性**
本物の実装とテストダブルとを取り替えられるような柔軟性がコードに求められる。さもなければ、相当のリファクタリングが必要になる可能性がある
**応用性**
テストダブルを不適切に利用するとテストが脆く、複雑になる可能性がある。
**忠実性**
本物のコードを忠実に再現しているかどうか。完全な忠実性がなくても利用が適切な場合が多い。
13.2 Googleでのテストダブル
Googleでのテストダブルには良い側面、悪い側面の両方が見られた。一つの教訓は、モッキングフレームワークの使いすぎは危険。現在はより現実的なテストを書く方を優先してモッキングフレームワークの利用は避けている。
13.3 基本概念
13.3.1 
テストダブルの利用例の一つは、クレジットカードのチャージを含む関数で、本物のテストでチャージするのはまずいため、テストダブルで置き換える
13.3.2 シーム
ユニットテストを書ける形式のコードは**テスト可能**であると言われる。**シーム**はテストダブルを利用してコードをテスト可能にする方法だ。**ディペンデンシーインジェクション**もシームを導入する一般的なテクニックだ。
13.3.3 モッキングフレームワーク
JavaのMockitoなどがその例。
@Mock CreditCardService mockCreditCardService をテスト内に書き、テストコードの中で以下のコードを入れることでモックオブジェクトの挙動を定義。
 when(mockCreditCardService.chargeCreditCard(any(), any())).thenReturn(false)
 13.4 テストダブル利用のためのテクニック
 13.4.1 フェイキング
 例えばメモリー内データベースなど。本番環境には適していないが、本物の実装同様に振る舞うAPIの軽量な実装。テストで使いたいオブジェクトのフェイクがあるとは限らない（ないことが多そう）。また、フェイクは本番同様の挙動を保つ必要があるので、書くのが難しい。
 13.4.2 スタビング
 スタブは when(mockCreditCardService.chargeCreditCard(any(), any())).thenReturn(false) のように関数が返すべき正確な値を指定するもの。スタビングはモッキングフレームワークを通じて行われるのがほとんど。
 13.4.3 インタラクションテスト
インタクションテストはあるメソッドの関数がどのように呼び出されるかを、実際にその関数の実装を呼び出すことなしに検証すること。使いすぎると脆いテストに陥るため、可能なら避けるべき。
13.5 本物の実装
Googleは本物の実装を優先してきた。これは、古典的テストと言える。そのほうがスケールしやすいことがわかったからだ。
13.5.1 分離より現実に即することを優先せよ
ユニットテストがテストダブルに依存しすぎると、同じレベルの信頼を得るために、エンジニアはインテグレーションテストを実行するか、もしくは手動でそれらの機能が期待通りに動作しているかを検証しなければならない。本番の実装にバグが含まれている場合、連鎖的に多くのテストが落ちることになるだろうが、CIシステムなどの開発者ツールが優れていれば、その失敗を引き起こした変更を突き止めるのはたいてい容易。
（個人的意見では、仕様変更を多く伴う場合にはテストをガラッと変えないといけないので、この本物の実装を優先するのは手放しには賛成できない。つまり、コードの柔軟性は無くなるよね。ケースバイケースなんだろうけど。）
13.5.2 いつ本物の実装を使うべきか決める方法
値オブジェクトには本物の実装が利用されるべきだが、その他もう少し複雑なケースでは以下のようなことを考慮する必要がある
**実行時間**
テストダブルの方が基本的には早くなる。並列化で時間の問題をかなり軽減できる
**決定性**
例えばスレッドの実行順序によって結果が変わるようなコードを対象にしている場合や、外部のHTTPサーバを利用していて過負荷で失敗するかもしれないといった場合、現在時刻に依存して処理が変わる場合などにはテストダブルを利用できる。
**依存関係**
依存関係を全て構築しなければならない場合にテストダブルが良さそうに見えることがある。理想の解法は自動DIやファクトリーメソッドの利用である。
13.6 フェイク
本物の実装が利用できない場合に、フェイクを用いることが最良の選択肢であることが多い。テスト対象のシステムからは、やりとりしているのが本物なのかフェイクなのか判別できない状態であるべき。
13.6.1 なぜフェイクが重要なのか
フェイクの実装は高速で、本物の実装を利用する際の欠点なしに効果的にコードをテストできるようにしてくれる。
13.6.2 どんな場合にフェイクが書かれるべきか
本番コードが変更されるとそれに伴って変更する必要が出る可能性があるため、フェイクは保守コストが高い。また、本番コードのオーナーがフェイクも書くべき。高い保守コストと生産性の改善を天秤にかける必要がある。
13.6.3 忠実性
フェイクの忠実性は、テストの観点から見た場合のみを考えれば良い。完全な忠実性を持っていない、本物の実装が持つ機能の100%を持っていなくてもOK。もし、実装していない機能が呼ばれたらエラーを返すようにしておけば良い。
13.6.4 フェイクはテストされるべき
フェイクはテストされるべきで、その一つの方法はAPIの公開インターフェイスに対してテストを書き、本物の実装とフェイクの双方にそのテストを実行すること。
13.6.5 フェイクが利用できない場合
フェイクが使える状態で用意されていないなら、まずはAPIのオーナーにフェイクを作成するように依頼すべきだ。そうでない場合は、自分で作ることができるかもしれない。方法としては、APIへの呼び出し全てを単一のクラスにラップし、それからそのAPIに実際には通信しないフェイククラスを作成するという方法がある。
13.7 スタビング
スタビングは挙動をハードコードしてテスト内の本物の実装を置き換えるものである。
13.7.1
スタビングはテストに適用するのが非常に容易なので、本物の実装を使うのが難しい場合に良さそうに思われるが、多用すると保守コストが跳ね上がる。
13.7.2 テストが不明確になる
スタビングのために余分にコードを書く必要があるので、テストコードが難解になりがち
13.7.1.2 テストが脆くなる
スタビングはコードの実装詳細がテスト内に反映されることになるので、本番コードが書き換えられた時にテストコードの変更が必要になる可能性が増える。（理想的にはテストはAPIの挙動が変化する時に変更の必要性が出るべき。）
13.7.1.3 テストの効果が落ちる
スタビングが本当に本物の実装のように振る舞っているかはわからない。また、状態を保存しないので、例えばsave()をした後にget()でとってくるようなことはできない。
13.7.2 スタビングがどんな時に適切か
本番コード内で呼ばれているある関数が、ある特定の値を返したことにしたいとき。
13.8 インタラクションテスト
インタラクションテストは関数がどのように呼ばれるかを、その関数の実装を実際に呼び出すことなく検証する方法である。
13.8.1 インタラクションテストよりステートテストを優先せよ
インタラクションテストでは関数が呼ばれているということを確認するだけで、テスト対象システムが正常に動いているかどうかはわからない。Googleでは、インタラクションテストを使いすぎているテストは冗談めかして変更検知器と呼ばれる。
13.8.2 インタラクションテストが適切なのはどんな時
- 本番の実装もフェイクも使えないため、ステートテストを実施できない時。
- 関数への呼び出しの回数または順序の違いが、望ましくない挙動を引き起こすかもしれないとき
インタラクションテストはステートテストを完全に置き換えないので、ユニットテスト内でステートテストを実施できない場合はより範囲の広いテストを用いてテストスイートを補うべき。
13.8.3 インタラクションテストのベストプラクティス
**状態変更型関数向けの場合のみインタラクションテストを選べ**
sendEmail(), saveRecord(), logAccess()などは状態変更型の例。つまり、テスト対象システムの外の世界への副作用がある関数である。そのほかの、副作用のない関数は非状態変更型である。
**過剰な指定は避けよ**
メソッドではなく挙動をテストするのが有益。
例えば、verify(userPrompt).setText("A", "B", "C")が指定しすぎな場合、
verify(userPrompt).setText(any(), eq("A"), any())として、挙動に重要な部分のみに絞ることができる。これは、関係のない挙動によって失敗することを防ぐ。
# 14章 大規模テスト
大規模テストには小規模テストにあったような環境制約（単一プロセス内で完結させるなど）はない。そのため、以下の特徴を持つ
- 遅いかもしれない
- 密閉されていないかもしれない。大テストは、他のテストやトラフィックとリソースを共有しているかもしれない。
- 大規模テストは非決定性かもしれない。他のテストやユーザ状態が大テストに干渉するかもしれない。
大テストはシステム全体が意図どりに動作していることについて一層の信頼を提供できる上に、手動テストよりもスケールする。
14.1.1 忠実性
本番環境はテストにおける忠実性が最高の環境である。また、本番環境の次に忠実性が高いのは、ステージングである。
14.1.2 ユニットテストでよくある不足分
- 忠実でないテストダブル。モックを作った人が本当の挙動を勘違いしている可能性もある。
- 設定の問題。本番には設定ファイルや設定DBがあるが、それらはユニットテストではテストできない。実は、Googleでは設定変更が原因の第一位である
- 負荷がかかると起こる問題。パフォーマンス、負荷、ストレスをテストしたい場合によく必要になる大容量トラフィックはテストが難しい
- 予期しない挙動、入力、副作用。ユニットテストは予期される挙動と入力のみテスト可能。Hyrumの法則を意識してほしい。
- 不意に起こる挙動と真空効果。ユニットテストでは本物の依存関係やネットワークのトラブルは意図的に排除されている。
14.1.3 なぜ大規模テストを備えないのか
優れたユニットテストには信頼性がある、高速である、スケーラブルであるという性質を満たすが、大規模テストはこれらの全てに違反することが多い。また、大規模テストはインフラストラクチャーとプロセスの面での標準化が欠如している。
14.2 Googleの大規模テスト
14.2.2 Googleスケールでの大規模テスト
依存関係が複雑になってくると（複数のサービスから動くなど）テストダブルの忠実性が下がる。Googleのスケールでうまく動作する方式で大規模テストを実施しつつも忠実性を適度に高く維持することが、決定的に重要となる
14.3 大テストの構造
大テストは通常以下の段階があるワークフローで構築される
- テスト対象システムを取得
- 必要なテストデータをシードとして与える
- テスト対象システムを用いて動作を実行
- 挙動を検証
14.3.1 密閉されたSUTの利点
本番環境テストはリリースするまでできないので、本質的に手遅れである。また、うっかりテストデータを出してしまうことがある。代替案はステージング環境を作ることだが、ステージングを占有してのテストはエンジニア数の増加、サービス数の増加とともにスケールするわけではない。
14.3.1.2 問題の境界でSUTの規模を縮小する
UIテストは信頼性がなく、コストが高い。
UIとバックエンド全てを対象にするエンドツーエンドテストは便利な一方でコストが跳ね上がるので、代わりにUI/API境界で分割した方が良い。また、DBをインメモリDBにするなど、全てを本番同様にする必要はない。
14.3.1.3 記録、再生の代理機能
テストダブルが実際の挙動を反映しているかを調べるのに消費者駆動契約テストのフレームワークを利用できる。これは、クライアントとサービスの双方にとっての契約を定義するもので、具体的に何を入力するとなんの出力が出るのかを定義するもの。Ract Contract Testingおよび、Spring Cloud Contractsの2ツールが公開されている。なお、Googleでは利用されていない。
Googleでは、トラフィックのログを記録する記録モードのテストを本番で利用し、いくつかの小規模な「再生モード」のテストを作る。「再生モード」は開発中とリポジトリー提出前コードのテスト中に利用される。
14.3.2 テストデータ
テストデータの取り方には、手動作成、コピー、サンプリングがある。手動では大きなデータは作れない、その場合はコピー。コピーが大きすぎる場合はサンプリング。
14.3.3 検証
SUTにトラフィックが送信された後、SUTの挙動を検証する必要がある。
挙動の検証には手動や、アサーション（assertThat(response.contains("Colossal Cave")など）、A/B比較（差分）などの手法がある
14.4 大規模テストの類型
**一つ以上のバイナリの機能テスト**
マイクロサービス館でさまざまなサービスが別個のバイナリとしてデプロイされている場合などがこれにあたる。関連バイナリ全部から構成されるSUTを起動し、公開APIを通じてそのSUTと相互作用することで、バイナリ館での本物の相互作用を対象に含めて扱うことができる
**ブラウザとデバイスのテスト**
公開APIとその不当なを通じ相互作用を行うテストを設けることで、提供するカバレッジのそうがさらに厚くなる
**パフォーマンス、負荷、ストレスのテスト**
これらの類型では、SUTはクラウド上にデプロイされ、分離されており、パフォーマンスの差分を検証することになる。マシン差があると測りにくいので、2つのバイナリを同じマシン上で実行する必要がある。
**デプロイ設定のテスト**
基本的にはSUTが起動すればデプロイ設定は間違っていないということなので、追加のデータや検証は不要である
**探索的テスト**
このテストはテスターによって手動で行われるもので、システムの到達可能パスを辿ってもらうことでカバレッジをあげられる。また、バグを見つけたら、自動で行う機能テスト向けの新テスト項目を得られる。エンジニアのチームと関連人員を招いたミーティングを設定し、製品を手動でテストしてもらう**バグバッシュ**と呼ばれる手法がある
**A/B差分リグレッションテスト**
クラウド上にデプロイされ、分離されている2つの環境にトラフィックを送、レスポンスを比較する形式である。Googleでは最も一般的な大規模テストの形式。A/B/Cテストとなることもある。
A/B差分テストはローンチ済システムの予期しない副作用を検知する低コストかつ自動化可能な手段だ。
**ユーザ受け入れテスト**
ユーザにとって意図通りに動作するかを確認する自動テストでありCucumberとRSpecなどのツールがある。
**プローバーとカナリア分析**
本番環境に対してコード化されたアサーションを実行する。書き込みなどは副作用があるので要注意。ブローバーは動作している本番環境に対して行われ、カナリア分析は本番環境にリリースがプッシュされる前に行われる。通常はCIと合わせて行われる。
**カオスエンジニアリング**
Googleは何年もの間DiRT（Disaster Recovery Testing）という模擬演習を実施している。本番に影響を与えるので、エンドユーザにも影響が出る。
**ユーザ評価**
ドッグフーディングでフィードバックを得たり、実験として一部ユーザに機能を開放する、人間の評価者に評価してもらうなど
14.5 大テストと開発者ワークフロー
多くの大テストはTAP（テスト自動化プラットフォーム）には属さない。
14.5.2
大テストを書けるようにするには明確なライブラリ、ドキュメンテーション、テストコード例を備えることが必要だ。保守テストについても考える必要がある。
14.5.2.1 大テストの高速化
テスト範囲を狭めるか、小規模なテストに分割して並行動作できるようにするのが、テストの速度を上げる最良の方法であることが多い。他の秘訣もある
14.5.2.2 信頼不能性の排除
信頼不能性があると、大規模テストにとっては利用不能に陥る可能性もある。信頼不能性の最小化はまず、テストの範囲を狭めることからである。他のテクニックとしては、タイムアウトを増加させることや、イベント駆動にすることがある
14.5.2.3 テストを理解可能にする
テストが何の原因で失敗しているのかを明確に特定するメッセージを備える
複数のプロセス協会に関数呼び出しがスタックトレースは大規模テストには有用ではない。Dapperなどのフレームワークを用いて、ログにリクエスト毎のIDをつけて後から追跡しやすくすると良い。
また、テストのオーナーやその他のサポートできる人へのコンタクトを簡単にすると良い。
14.5.3 大規模テストのオーナーとなる
大規模テストが然るべきオーナーシップをかくと、テストの変更と更新が難しくなるし、失敗した時の解決に時間が長くかかるようになってしまう。9章のオーナーシップと同様の方法で、明確化すると良い。または、テスト毎のアノテーションにオーナーをドキュメント化すると良い。
## 15章 廃止
旧システムから脱する系統的な移行と、旧システムの最終的な撤去からなるプロセスを**廃止**と呼ぶ。
15.1 なぜ廃止するのか
まず、**コードは債務であり、資産ではない**という基本前提がある。システムはコストと時間を費やして保守しなければならないからだ。だが、ただ単に古いだけでは、廃止は正当化されない。
廃止することが妥当なシステムには、旧式であることが実証でき、匹敵する機能を提供する置き換え先システムが必須である。新旧2つのシステムの維持には特殊な変換コードが必要になるかもしれないし、発展に伴い相互依存のようになって最終的にどちらも撤去できなくなるかもしれない。つまり、同じ機能を実行するシステムがあると、長い目で見て新しいシステムの発展が阻害する可能性がある。
また、廃止作業を同時に行うには限界量があるようだ。
15.2 なぜ廃止はこれほど難しいのか
Hyrumの法則で、新システムに移行すると以前のような使い方ができなくなるユーザはいる。また、旧コードに愛着をもったエンジニアを納得させなければならない。システムが旧式だと、組織はコストが増える。これに対する対処法としては、履歴も検索可能にすることだ（17章参照）
廃止に関する取り組みに予算をつけて実行するのは難しいことがある。放置コストが容易にはわからないからだ。
廃止はシステムを稼働させたままリファクタリングの形で発展させる方が容易なことが多い。
Google車内で観測されたことには、新システムへの移行は極めてコストが高く、低く見積もられがちである
15.21 設計中の廃止
原子力発電所のように設計時点で廃止について考え、廃止のための予算を確保するまで考慮しているソフトウェアシステムは稀である。
廃止可能なシステムを設計する際に考慮すべき検討事項としては以下のようなものがある
- ユーザが新しいシステムに移行する際の容易さはどの程度か
- どうすれば自分のシステムをインクリメンタルに置き換えられるか
15.3 廃止の類型
廃止は2つのプロセス群の連続体
**勧告的廃止**
締め切りがなく、優先度が高くない廃止である。願望的廃止とも言える。アーリーアダプター的にユーザに新システムを利用してもらうのは良い方法である。ユーザにとって大きな利点がその新システムにある場合は積極的に乗り換えてもらえるだろう。
**強制的廃止**
締切を持つ廃止。締切を過ぎても移行しなかったユーザは機能が制限されたりする。
15.3.3
ユーザに対して出される非推奨の警告は行動可能性と関連性を持っていなければならない。警告に従って何らかの行動を取れるならそれは行動可能と言える。また、警告が有用であるためには、必ず関連性があるべき。
15.4 廃止プロセスを管理する
廃止プロセスも他のソフトウェアプロジェクトに似た管理と実行の方法を取ることになる
15.4.1 プロセスのオーナー
明示的にプロジェクトオーナーを儲けるべきである。廃止の取り組みを中央集権的に行うことで、専門知識によりコストがわかりやすくなり、また、実際に削減される結果が確実になりやすい。誰も明確なオーナーシップを持っていないプログラムが旧システムに依存していることもある。多くの場合は廃止は優先度が比較的低いとみなされるが、20%ルール（業務時間の20%を通常プロジェクト以外に費やして良いこと）で廃止の作業をやるのが良い。
15.4.2 マイルストーン
撤去作業を成し遂げても、チーム外の誰にも全く気づかれないことが多い。完全な撤去を唯一のマイルストーンとおくべきではなく、より具体的でインクリメンタルなマイルストーンがあると式の面で良い影響がある。
15.4.3 廃止ツール環境
ツールについては大規模変更プロセス（22章）、Googleのコードレビュー用ツール（19章）がある
15.4.3.1 発見
旧システムがどのように、誰によって使われているかの知識は廃止プロセスの間ずっと役にたつ。GoogleではCode SearchやKytheによってあるバイナリをどの顧客が利用しているか明らかにしている。また、社内のグローバルなテストスイートを、古いシンボルへの参照が全て削除されているかどうかの確認方法としている
15.4.3.2 移行
ほとんどの実行作業はコード生成とレビューツール環境のセットを利用して完遂できる
15.4.3.3 後戻りの防止
旧システムの廃止中にユーザが利用箇所を増やしてしまうことは起こり得る。これはモグラ叩きのようになって非生産的だし、士気を下げる。GoogleではTricoder性的解析フレームワークを用いて廃止予定システムを呼び出しているユーザに通知を行う。また、@deprecatedのようなアノテーションも有効である。通知メッセージには移行先が含まれるべき。また、ボタン一押しの簡単な操作で自動的に置き換えしてくれる修正をツール環境が提案してくることもある。
## 16章 バージョンコントロールとブランチ管理
VCSは皆利用すべき。DevOpsにより広められたトランク（=gitでいうmainブランチ）ベース開発はバージョンコントロールのポリシーのアプローチの中でも特にスケーラブルである。
16.2 ブランチ管理
進行中の作業はそれぞれがブランチに相当する
16.2.1 開発ブランチ
製品の安定性向上を目指すための手段としてdevブランチを多用するのは間違っている。大きなdevブランチをマージすると、失敗原因がわかりにくくなってしまう。また、devブランチを依存する場合、長期間分離して開発されている複数のブランチがあるとマージのためのコストがトランクベース開発の場合のコストを上回る可能性がある。
16.2.2.1 いかにしてdevブランチ中毒となったか
devブランチを多用してしまうのは、ブランチのマージを遅らせて、調整に専念するため。
16.2.3 リリースブランチ
devブランチがブランチのブランチを作られる可能性がある一方で、リリースブランチはリリース後には捨てられることが期待される。しかし、最も機能している組織はリリースブランチをスキップする。
16.3 Googleでのバージョンコントロール
GoogleではPiperという中央集権的なVCSに依存している。PiperはGoogleの内製なので、色々とカスタマイズ可能。
16.4 モノリポ
モノリポを採用するとリポジトリを探す手間が省ける。git submoduleはモノリポを模倣するようなツールである。
## 17章 Code Search
Code SearchはGoogleのコード閲覧と検索のためのツールである。これを学ぶのは、IDEに収まりきらない規模のプロジェクトを担っているエンジニアにとっては有益である（自分はそうではないと思うので途中で読み飛ばしてしまった）。現在は、このシンボルはどこで定義されているか、どこで使われているか、どうやってインクルードするか、コードベースにいつ追加されたのかなどの質問にもクリック1, 2回で答えることができる. IDEとは異なり、Code Searchはスケールする状態でコードを読み、理解し、探索するというユースケース向けに最適されており、そのためバックエンドにかなり依存している。
17.1 Code SearchのUI
検索ボックスで検索すると結果ページが返される。関連性ランキングと、シンタックスハイライト処理やスコープ、コメント認識など、複数の機能強化を加えている。また、Code Serchはコマンドラインからも呼ぶことができる。
17.2 グーグラーはどのようにCode Searchを使うか
特定の情報がどこに存在するかを調べるため ... 16%
コードの特定部分が何を行っているか調べるため ... 25%
他者が何かをどのように行なったか ... 33%
なぜ追加されたか、なぜその挙動を取るのか ... 16%
誰がいつ導入したのか ... 8%
17.3 なぜ独立したウェブツールなのか
Google社外では大半の調べ物はローカルのIDE内で行われているらしい。
17.3.1 スケール
Googleはコードベースが大規模すぎてほとんどのIDEではローカルにおいたコードベース全体のコピーが、単一のマシン上には入らない。IDE起動時に払わされるインデックスの構築のコストももかなり大きい。Code Searchではリポジトリーに提出される全変更ごとにインクリメンタルに更新され、インデックス構築は線形になる。
17.3.2 設定不要のグローバルコードビュー
IDEとは異なり、ウェブツールであれば面倒な設定は不要。
17.3.3 専門化
IDEはコードの編集機能に最適化されている場合が多いが、Code Searchは閲覧と理解に最適化できる。
17.3.4 他の開発者ツールとの統合
ログやコンパイルエラー、テスト、ドキュメンテーションにもCode Searchを統合できる。
17.3.5 API公開
APIが公開されているので、それらを自身のツールに組み込むことができる。主要なエディタ、IDEにも検索と相互参照の機能を提供するプラグイン群が書かれている。
17.4 設計上でのスケールの影響
Code Searchは分散システムによるスケーリングを行っている。
17.4.1検索クエリのレイテンシ
頻繁に起こる操作の全ては200ミリ以下のエンドツーエンドでのレイテンシを目標としている。
17.5 Googleの実装
Code Searchのチームがどのようにしてこのツールを作ったのか。
17.5.1 検索インデックス
検索レイテンシの中央値は0.5, インデックス化は10秒以下である
手法はこのように変化してきた: トライグラムベース->Suffix Arrayベース->n-gram 
17.5.2 ランキング
ランキングは通常スコア付関数から始まる。スコアが良いほど良い結果となる。スコア付関数はファイルの特徴セットにスコアを対応させる。ファイルの長さ、利用されているプログラミング言語はクエリ独立なシグナルであり、関数定義か文字列リテラルのどちらかにマッチするのはクエリ依存のシグナルである。
## 18章 ビルドシステムとビルド哲学
Googleで働くことの何が好きかの問いに対して、ビルドシステムという回答が多いらしい。
18.1 ビルドシステムの目的
ビルドシステムには速さ、正しさが求められる。ビルドシステムは複数回のビルド、自動テストやそれによる破壊的変更の防止などさまざまなワークフローがある
18.2 ビルドシステムがないと何が起こるか
ビルドシステムがないと開発がスケールしない
18.2.1
javacのような方法でコンパイルすることは最も原始的なビルドであるが、javacは他の場所に保存されているコードを探し出す手段がないので、少し複雑になると複数の依存関係をそれにあったツールで、順番を考慮しながらビルドする必要がある。依存関係をインターネットからダウンロードしてビルドすることも可能ではあるが、どんなライブラリがlibに入っているか、まだ利用されているのかは忘れてしまいやすい。
18.2.2 シェルスクリプトは救援となるか
趣味プロジェクトでも、問題が出始めた場合、シェルスクリプトは解決方法になるかもと思われるかもしれない。実際、一時的には助かるが、結局は一層多くの問題が降りかかる。シェルスクリプトが複雑になったり、遅くなったり、リリースや障害で手間がかかるようになる。
18.3 現代的ビルドシステム
汎用ビルドシステムは根本的にはスクリプトによるDIYのアプローチとさほど変わらないが、自作するよりも堅牢かつ柔軟。
18.3.1 依存関係こそ全て
依存関係が最も複雑で難しい。
18.3.2 タスクベースのビルドシステム
Ant, Maven, Gradle, Rakeなどはタスクベースのビルドシステムで、ビルド実行方法を記述するビルドファイルの作成をエンジニアに要求する。ビルドファイルでやっていることはスクリプトと似ているものの、別ディレクトリに新しいビルドファイルを作成して相互にリンクさせることが可能
18.3.2.1 タスクベースのビルドシステムの暗黒面
タスクベースのビルドシステムはビルドファイルに書かれたことをその通りにやるので、効率的なスケジューリングややるべきことをやっているかの確認をシステムはできない。そのため、複雑性が増す。これは、エンジニアに権力を与えすぎていると言える。
18.3.2.2 ビルドステップの並列化の難しさ
タスクベースのビルドシステムは並列化できる場面でもできないことがよくある。
18.3.2.3 インクリメンタルなビルド実行の難しさ
全コードベースを一からビルドしないで済むような、インクリメンタルなビルドが優れている。しかしながら、タスクベースのビルドシステムはここでも四苦八苦する。タスクがすでに完了していることをチェックする汎用的な方法がないからだ。そのため、再実行することが多い。
18.3.2.4 スクリプトの保守とデバッグの難しさ
ビルドスクリプトはバグの温床になり得る。
18.3.3 アーティファクトベースのビルドシステム
アーティファクトベースのビルドシステムはエンジニアに「何を」ビルドするか指定するファイルを書かせ、ビルドの手順（HOW）はシステムに任せるようなやり方を取る。アーティファクトベースのビルドシステムに求められるマニフェストは、関数型言語に近いものがあるらしい。また、並列化も行いやすい。GoogleのBazel、Blazeがアーティファクトベースのビルドシステムの例である。
BazelではBUILDファイルでターゲットを定義する
18.3.3 分散ビルド
Googleでは単純な部類のバイナリですら何万もの依存関係を持つ。そのため、分散ビルドでスケールさせる必要性がある。
18.4.4.1 リモートキャッシュ保存
アーティファクトをビルドする際に、リモートにあるキャッシュにすでに存在するかチェックし、存在しなければビルドしてキャッシュする。頻繁に更新されないものは1回ビルドしたものをユーザー間で共有することでビルドシステムの運用コストが大幅に低下する。
18.3.4.2 リモート実行
リモート実行は以下のような流れである。
ユーザのマシンがビルドマスターにリクエストを送ると、ビルドマスターが複数台のワーカーにアクション群の実行をスケジュール設定する。各ワーカーは指定された通りに成果物をキャッシュに書き出す。各ワーカーは他のワーカーによって出力される依存関係が必要な場合はビルドマスターによってブロックされ、必要な依存関係がキャッシュに書き込まれるとそれを読んで進むことができる。Googleはリモートキャッシュとリモート実行の両方を用いるbんさんビルドシステムを利用している。
18.3.5 時間、スケール、トレードオフ
どの種類のビルドシステムを利用するかにはトレードオフが存在する。DIYアプローチは最小規模のプロジェクトか組み込みのビルドシステムを持つGoなどのプログラミング言語向けのみに機能する。タスクベースのビルドシステムを利用するとスケールがより向上する。一方で、ビルド構成を考えなければならない、ビルドファイルを書かなければならないなどのトレードオフが発生する。プロジェクトがさらに大きくなると、アーティファクトベースのビルドシステムを用いるべきである。一方で、アーティファクトベースはビルド用のコードを書くのではないため、システム内での作業が必要となり、結果的に柔軟性を失うというトレードオフがある。
# 19章 GoogleのコードレビューツールCritique
成功するレビューツール環境というものは何によって構成されているのかを考察していく。Critiqueはコードが取り込まれる前の門番役として監視することを支援するほか、コード考古学にとっても有用である。
19.1 コードレビュー用ツール環境の原則
Critiqueは以下の原則を重視するようにデザインされている
- 単純さ。わかりやすいUI
- 信頼の基礎。例えば、コード作者を信頼し、コードレビューが実際に対処されたかの二重チェックは行わない。
- 汎用コミュニケーション。汎用な手順でコメントできる。
- ワークフロー統合。他の中心的ソフトウェア開発ツールとの統合ポイントがある。
19.2 コードレビューのフロー
コード作成->レビューのリクエスト->コメント->コードの修正とコメントへの返信->LGTM->コミット という流れである。柔軟に変えることも可能で、レビュアーは他のレビュアーを任命して外れても良いし、緊急時にデプロイしてコミット後のレビューとしても良い。
19.2.1 通知
Critiqueはイベント通知を発行できる。レビュアーの順番が回ってきたり、なんらかのリポジトリ提出前処理が失敗した場合に、Chrome拡張を利用してイベント通知を受け取れるようにすることができる
19.3 第一段階:コード変更を作成
（GitLab等とそれほど変わらない気がするのでカット）
19.3.2 静的解析
静的解析の結果が出てくる。そこから該当コードに素早く移動できるし、数回のクリックで問題についての解説と修正提案が出てくる。クリックで適用することもできる（便利！）
19.3.3 緊密なツール統合
Googleの他のサービス（Code Searchなど）との統合も行われている。
19.4 第二段階:レビューをリクエストする
GwsQと呼ばれるe-mailのエイリアスがあり、あるチームのメーリングリストのエイリアスを設定できる。それをレビュアーとして指定すると、GwsQがその中から特定メンバーを選ぶ。Googleほどの規模だとレビュアーを探し出すのが難しくなることが多いが、Critiqueはレビュアーを選ぶ機能がある。
19.5 第三段階と第四段階:コード変更の理解と、コード変更へのコメント付加
19.5.1 コメント付加
Critiqueで、コメントするという行動はコード閲覧に次いで二番目によく起こるものだ。コメントは誰でもできる。レビュアーが何をレビューしたかを把握するためにファイルごとにレビューしたかどうかのチェックボックスが用意されている。ファイルが変更されるとチェックボックスは外れる。コメントにはコードを提案することもできるし、AckやDoneを知らせるボタンもある
19.5.2 コード変更の状態を理解する
レビュー及び作者の状態を表示するダッシュボードがある。
19.5.2.1 「誰のターンか」機能
Critiqueは注意セットを管理して、次に誰に行動を起こしてもらいたいのかの確定を補助する。注意セットはレビューがその者で止まっている者たちのグループからなる。この機能の実装前を想像し難いが、以前は、レビュアーとコード作者間でチャットを行い、コミュニケーションをとっていた。
19.5.2.2 ダッシュボードと検索システム
ダッシュボードはChangelist Searchという検索システムによって支えられている。また、UIはカスタマイズができる
19.6 コード変更の承認
スコア付けはLGTM, 承認, 未解決コメントの数の3つに分割されている。承認は「門番として、私はこの変更がコードベースにコミットされることを許可する」という意味だ。全ての変更は承認状況とLGTMの両方を必要とするので、少なくとも2対の目がそのコード変更を見たことが保証されている。また、コード変更をコミットする準備が整ったらコード作者に通知できる。作者が修正することを信頼して未解決コメントを伴ったコード変更をLGTMすることも許される。
19.7 第6段階コード変更のコミット
コミット用のボタンを押せばコミットできる。
Critiqueはコード考古学のためのツールとしても利用できる。あとから問題が見つかった時にコメントを残しておくこともできるし、ロールバックもできる。
ちなみに、OSSなど、Critiqueを使うのが難しい場合はGerritというOSSのコードレビューツールが代わりに使われるらしい
# 20章 静的解析
静的解析の静的はプログラムを実行せずにという意味である。静的解析はバグを見つけるのに役立つが、それだけにとどまらない。ベストプラクティスをコードかし、現代的なAPIバージョンに合わせてコードが更新され続けるように促し、技術的負債を防ぐか減らせる。開発者の教育にもなり、アンチパターンが入ることを抑制できる。
20.1 効果的な静的解析の特徴
近年の静的解析ツールはスケーラビリティとユーザビリティを向上するためのアプローチが着目されつつある。
20.1.1 スケーラビリティ
プロジェクト全体ではなく、保留中のコード変更の影響を受ける部分だけを静的解析の対象とする。
20.1.2 ユーザビリティ
静的解析の警告を修正するとバグが生まれる可能性もある。特に動いていて頻繁に更新されているわけではないコードは修正の必要性も薄い。そのため既存の問題については重大なもの
のみを目立たせる。そのほかはコードの変更で新しく出てきた問題を表示する
20.2 静的解析を機能させる際に鍵となる教訓
20.2.1 開発者の幸福を重視せよ
後検出率が低い静的解析ツールのみをデプロイしている。また、フィードバックを能動的に募り、フィードバックに基づいて行動する。また、厳密には正しいが、混乱させるメッセージでユーザが後検出だと誤って解釈する可能性もある。これを実質的誤検出という。
20.2.2 静的解析を中心的な開発者ワークフローの一部とせよ
コードレビュープロセスの中で、静的解析が実行される。
20.2.3 コントリビュートする権限をユーザーに与えよ
生産されるコードを自身の備える知識によって改善できるドメイン専門家がいるので、彼らに新しい静的解析ツールやツール内の個別チャックを書いてもらうと、スケールする形で専門知識の活用ができる。
20.3 Tricorder:Googleの静的解析プラットフォーム
TricorderはCritiqueに統合されている。価値ある結果のみをユーザに届けるようにすることにこだわっている。Tricorderには解析類型（アナライザーと呼ばれる）以外に個別のチェックがGoogle開発者によってコントリビュートされている、
20.3.2 統合されているフィードバック経路
Tricorder内には解析結果に対して「役に立たないボタン」を押すことができ、アナライザーを書いたものに対してその理由を提出できる。これは良い改善の機会となる。Tricorderのチームは「役に立たないボタン」のクリック率が高いアナライザーを追跡しており、改善しない場合には無効化する。
20.3.3 修正提案
可能な場合には修正の提供も行う。特にスタイルについては自動修正されるべきだ。エンジニアは「修正してください」ボタンを押すことで自動で修正してもらうことができる。修正提案は補助的なドキュメンテーションとしても有用。
20.3.4 プロジェクトごとのカスタマイズ機能
特定プロジェクトに追加の任意選択アナライザーを実行できる機能が与えられている。また、任意選択だったがデフォルトで有効化されるアナライザーに掌握したアナライザーもある。
20.3.5 リポジトリー前処理
コミットを阻止する静的解析も追加できる。コード変更に対応するテストファイルが存在することを保証したり、コミットメッセージに「DO NOT SUBMIT」という文字列を含んでいないかなどをチェックする。時チーム用にカスタムなリポジトリー前処理を書くことも可能。
20.3.6 コンパイラー統合
コンパイラの処理ないに可能な限り静的解析を搭載するように試みている。コンパイラに持ち込むチェックは以下の3要素を含む
- 行動可能かつ修正が容易
- 実質的誤検出を生じさせない
- スタイルやベストプラクティスではなく、コードの正しさのみに影響する問題を報告する
また、コンパイラでは警告を出さず、エラーを出すかチェック結果を表示しない。なぜなら、コンパイラの警告はしばしば無視されるからだ。Go言語ではこのポリシーが極端に推し進められており、使われない変数やパッケージのインポートなど、他の言語では警告扱いの問題をエラーにしている。
# 21章 依存関係管理
依存関係管理の難しい点は可視性のない、外部のコード変更で自分のプライベートなコードと整合性が取れなくなってビルドが破綻する可能性があるという部分にある。また、スケールがさらにこれを複雑にする。Googleのアプローチは単一のリポジトリを持つ大規模組織であり、ソースコントロールのポリシーを用いて圧倒的にスケールアップが可能。
21.1 なぜ依存管理がそれほど難しいのか
十分な期間が経つと、依存関係ネットワークの全てのノードに新バージョンが出てくる
- 依存関係全ての互いに適合するバージョンを見つけやすくするには
- 依存関係のネットワークをどのように管理すれば良いのか
21.1.1 競合する用件群とダイアモンド依存関係
競合する用件を持つ異なるノードの両方に依存している場合に問題が出る。例えば、500pの図21-1ではlibaとlibbに依存するlibuserがあり、liba, libbはlibbaseに依存している。libaとlibbが異なるバージョンのlibbase依存していたら問題になる可能性がある。このダイヤモンド型の依存関係の問題は言語によって許容度合いが異なる。Javaはある程度許容するが、C++はほとんど許容しない。
競合する用件の問題に遭遇した時の最も簡単な解決法は別バージョンで互換性のあるものを見つけることである。だが、そもそも互換性のない状態の原因が最初に発見するエンジニアにとっておそらく不明。
さらに簡単な方法はダウングレードすることだが、アップグレードがセキュリティイシューに端を発する場合は選択してはならない
21.2 依存関係のインポート
プログラミングの観点では、再利用することは優れた判断であり、技術進歩の根本的な要素である。
Go言語はソースコードの互換性はほとんどの場合に保証されているが、バイナリの互換性は約束していない。
21.2.2 インポートを行う際に考慮すべき事項 

インポートする際は以下の質問リストを活用すべき
- そのプロジェクトには実行可能なテストがあるか
- テストは合格するか
- どんな類の利用法をそのプロジェクトは目指しているのか
- どんな利用法がサポートされるか、そのプロジェクトは詳細を述べているか
- 誰がその依存関係を提供しているか。評判を調べてみる価値はある
- そのプロジェクトの人気度
- どのくらいの期間そのプロジェクトに依存するのか
- どのくらい頻繁にそのプロジェクトはは快適変更を行っているのか
外部プロジェクトを利用する際にはオーナーを立てるべきであるが、時間の経過で根幹に関わる部分まで依存するようになったり、アップグレード作業で知識のある人が
全くいなくなっているという可能性に注意するべき。

21.3.1 「何も変化しない」
依存関係を決して更新しないことで安定を保証できる。つまりバージョンはひとつしかない。ただし、十分長期間にわたる場合このモデルは誤りに等しい。

2.3.2 セマンティックバージョニング
「依存関係ネットワークは昨今どのように管理するものなのか」という問の事実上の標準は、セマンティックバージョニング（Semver）である。
セマンティックバージョニングは2.4.7.2や1.1.4のような小数点を含むすじでバージョン番号を表す、あらゆる場所で利用されるプラクティスである。
liba >= 1.5, libb >= 1.4.7 のような感じでバージョンの要件を定式化する。SATソルバーに類似するSemVer用のバージョン充足可能性ソルバーを利用し解決を図ることができる

21.3.3 バンドルされたディストリビューションのモデル
組織が依存関係のコレクションを集め、コレクション単位でリリースするというもの。バージョン選択は専任のディストリビューターが管理する。`

21.3.4 リブアットヘッド
全ての物の最新バージョンを入れ、依存されている側は破壊的変更は可能な限り避ける。破壊的変更を行う場合は下流の依存関係が更新されるか、自動で修正できる形にするべき。

21.4 SemVerの制限

21.4.1 SemVerは課題に制約を貸す可能性がある。

SemVerの場合、メジャーアップデートが実際には受け入れることができる場合であっても書き換える必要がでる

また、課題に約束をするという側面もあり、マイナーバージョンアップであってもHyrumの法則から破綻する部分が出て来るかもしれない。
つまりは、複数の依存関係が連携して動作しないにも関わらず動作すると報告するかもしれない。

以下の条件下ではSemverが十分によく機能することが期待される。
- 依存関係の提供者が正確かつ信頼できる。（SemVerバージョン引き上げでの人為的エラーを避けるため）
- 依存関係の粒度が細かい
- 全APIの全利用が予期されている利用法の枠内に収まっている

Googleの経験上はスケールがSemVerの弱点を目立たせるものとなりがち。

21.5.1 依存関係のエクスポート

「ライブラリのオープンソース化」のような、無害で慈善にもなりうる活動が組織の損失になるケースもある。
- 実装が下手だったり、しかるべき保守が行われなかった場合、組織の評判を落とすことになる
- ブランチ間での同期を保てないようだとエンジニアリングの効率への負担となる恐れがある

# 22章 大規模変更

LSC(Large-scale change)の定義は、論理的には関連しているものの単一のアトミックな単位としてリポジトリーに提出することが現実的には難しいコード変更である。
ツール環境が大きさに耐えられなかったり、コード変更が大きすぎてマージの競合が毎回おこるせいかもしれない。

LSCのカテゴリーには以下のものがある
- 解析ツールによってありがちなアンチパターンを除去
- 廃止されたライブラリ機能の利用箇所を置換
- コンパイラアップグレードなどの、ローレベルのインフラストラクチャーの改善を可能にする
- ユーザを旧システムから新システムに移行させる

22.2

誰がLSCを扱うのかは、1章で書いた通り、インフラチームである。理由は以下の3つ
- 何十万個もの参照箇所を修正するのに必要なドメイン知識を持っている
- 開発チームなどは恩恵を感じにくい可能性があり、プライオリティを下げられる。
- LSCを要するシステム群のオーナーとなれる

22.3 アトミックなコード変更への障壁

LSCの障害としては以下のものが挙げられる
- 技術的制約 ... そもそもツール環境がその変更の大きさに耐えられない可能性がある
- マージ競合 ... 変更ファイル数が多いとコンフリクトする
- 幽霊の出る墓場 ... 長年誰も触っておらず、変更すると何が起きるかわからないようなコード。対策は頑張ってテストを書くこと
- 複雑な環境 ... 環境が単純で一貫性を持っていると自動変換などを適用しやすい。また、チーム特有のチェックはLSCでは省略してもらう。
- テスト ... 全てのコード変更はテストされるべきだが、LSCは難しい。
- コードレビュー ... 大きなコミットでレビューは手作業だと、大変だし、ミスも生まれやすい。かといって、手作業もメリットがあるので望ましい場合も多い。LSCを別々のシャードに分割すると検証が容易になる

22.4 LSCインフラストラクチャー

ポリシーと文化は不可欠。LSCを実行したいチームおよび個人のための、軽量の承認プロセスがGoogleではで上がっている

また、コードベースの内部的知識も必要。例えば、ツールで、どの関数がどこから呼ばれているかがわかるとやりやすい。

主要な変更を小さな部分シャードに分割し、各シャードでテスト、email送信、レビュー、コミットを独立に行うプロセスを管理するツール環境があると良い。

テストも必要。

また、言語によっては型エイリアスや転送関数などLSCに役立つ機能がある。静的型付け言語の方がLSCが容易らしい。また、フォーマッタも不可欠。

LSCのプロセスは1. 認可、2. コード変更の作成、3. シャード管理、4. クリーンアップ