## １章 ソフトウェアエンジニアリングとは何か

- 時間
ソフトウェアエンジニアリングにおいて、ソフトウェアの持続可能性は重要。変化に対応できるようにするべきだ。
最初のアップデートを切る抜けるだけでなく、その後も最新版に追随できる状態にすることがプロジェクトの長期的持続可能性の真髄である。
**Hyrumの法則**
あるAPIに十分な数のユーザーがいるとき、APIを作った者自身が契約仕様としてなにを約束しているかは重要ではない。 **作られたシステムがもつあらゆる観察可能(observable)な挙動に関して、それに依存するユーザーが出てくるものである**。
そこに少しでも複雑さがあれば、将来的に挙動が変わる可能性がある。そして、Hyrumの法則によってその影響を受けるユーザはいるはず。脆い、未公開の機能に依存したコードは、クレバーと言われるが、クレバーが褒め言葉で使われるならそれは「プログラミング」で、悪口で使われるなら「ソフトウェアエンジニアリング」である。
変化それ自体のために変化するべきではないが、変化の能力は備えていなければならない。
1.2 スケール
基本的に複数人で行うので、人数が増えてもうまくスケールし、効率性を落とさないことが重要だ
人件費、計算リソース、そしてコードベースもスケールする必要がある。全体ビルド一回の時間やプログラミング言語のアップデートに対するコストは気づかないうちに大きくなっていく
1.2.1
チャーンルールは、専門家が自分自身で顧客を新バージョンに移行させるか、システムを止めずに後方互換性のある形のどちらかにしなければならないというルール。これは割とスケールする。全顧客に対応法を考えてもらうより、専門家グループを作る方がさっさと終わる。
知識はウイルスのような拡散性がある
1.2.2
Beyonceルール ... テストで検知できない問題はインフラチームの責任ではない。（テストを書いておけばよかったのに）
1.2.3
Googleは2006年のコンパイラのアップデートに非常に苦労した。BeyonceルールもCIシステムも浸透しておらず、リグレッションを出しても責められないという確信を持つことが難しかった。->Googleはスケーリングの問題を克服し、長所に変えるべく、自動化、統合/一貫性、専門知識に注力し始めた。
コードベースの柔軟性に影響する要因は専門知識（アップグレードの方法を知っていること）、安定性（リリースを定期的に、頻繁にしており、リリース間での変化が少ない）、準拠性（アップグレードをすでに経ていないコードはほとんど存在しない）、馴染み深さ（アップグレードを十分に定期的に実施しているので、そのプロセスの冗長性を見出し、自動化できる）、ポリシー（Beyonceルールのようなプロセスやポリシーを有しているか）
1.2.4 左への移動
問題を早期発見するとコストが下がる
- トレードオフ
少ないメトリクス（指標）でトレードオフの判断を迫られる。選択肢は無数にあることが多い

ソフトウェアエンジニアリング vs プログラミング