# Go環境のセットアップ
macならこれでよし
```
brew install go
```
linuxなら
```
$ tar -C /usr/local -xzf go1.19.linux-arm64.tar.gz
$ echo 'export PATH=$PATH:/usr/local/go/bin' >> $HOME/.profile
$ source $HOME/.profile
```
サードパーティのモジュールやパッケージはホームディレクトリの下のgoディレクトリの下にダウンロードされる。コマンドはgo/binディレクトリの下。

go run hello.go は以下のような動作になっている
1. バイナリファイルがビルドされ、一時ディレクトリに置かれる
2. そのファイルを実行する
3. プログラム終了後、そのファイルが削除される
再利用できるように実行形式のバイナリファイルを作るには
```
go build hello.go
```
-oで、名前をつけることが可能
```
go build -o hello_world hello.go
```
go installはパッケージをダウンロードし、go/binに置く。

go fmtは便利なフォーマットツールであるが、その機能強化版であるgoimportsというツールもある。これは、フォーマットだけでなく、import文をクリーンにするのに使える

lintを使うとコードのスタイルがガイドラインに沿っているかを確認できる。一つのツールはstaticcheckである。
go install honnef.co/go/tools/cmd/staticcheck@latest でインストール可能
```
staticcheck
```
golangci-lintならいろんなスタイル関係のチェック（staticcheck, go vetなど）を一括でしてくれる。
```
golangci-lint run
```
.golangcli.ymlで、どのリンターを実行し、どのファイルを分析するかを指定可能。
詳細は https://golangci-lint.run/usage/configuration/

# 2章 基本型と宣言
Go言語では、宣言されたが値が割り当てられていない変数にはゼロ値が割り当てられる。

0bを先頭につけると2進数、0oなら8進数、0xなら16進数
x := 0b1101
また、アンダーバーを入れることもでき、1_2_3_4は1234となる

小数では、3.14の他、6.03e23のような指数標記も可能

- 1 文字の Unicode 文字(例: 'a' )
- 8 ビット 8 進数(例: '\\141' )
- 8 ビット 16 進数(例: '\\x61' )
- 16 ビット 16 進数(例: '\\u0061' )
- 32 ビット Unicode(例: '\\U00000061' )
このほか、「\」(バックスラッシュ)でエスケープされた rune リテラルもあります。次に主なも のをあげます。
- 改行( '\\n' )
- タブ( '\\t' ) シングルクオート
- 一重引用符( '\\'' ) ダブルクオート
- 二重引用符( '\\"' )
- バックスラッシュ( '\\' )

文字列は基本的にダブルクオーテーションの組を使って表すことができる。\nで改行できる。
「\\」、改行、あるいは「 " 」を含めたい場合は「\`」(バッククオート)で囲めば良い。これはロー文字リテラルと呼ばれ、「\`」以外の文字を含めることができる

byteはuint8の別名である。ただし、uint8が使われることは滅多にないので、基本的にbyteを使う。
runeはint32の別名である。文字を参照している場合はruneを使うようにする。

Goでは全ての型変換は明示的なので、論理型以外の型を論理型として扱うことはできない。他の言語であれば、ゼロ値以外ならtrue扱いになるが、Goではそういうことはない。

var x int = 10 のような方法で型宣言できるが、この例では右辺は整数リテラルなので、
var x = 10 としても同じ。int（環境によってint32かint64に変わる）ではなく、int64とか指定したい場合は上を使うべき。
分割代入も可能 var x, y int = 10, 20
型の異なる変数も可能 var x, y = 10, "hello"
x := 10のような宣言は**関数**内でのみ有効
以下のように新しい変数yがある場合は:=で既存の変数xを書き換えることが可能。
x := 10
x, y := 30, "hello"

変数をゼロ値に初期化する場合は var x intを使おう
複数の変数の宣言を1行で行うのは、複数の値を返す関数か「カンマ ok イディアム」からの戻り値を代入するときだけ

constはリテラルに「名前」を使えるためだけ。len関数やcap関数の値も格納できる。
型付き定数も宣言できる

Goは使われていない変数はエラーになる。使われた後に再代入されてから使われていないものについてはエラーは出ない（golangci-lintは警告を出すが）。なお、定数は使われなくてもエラーにはならない。

変数名にはキャメルケースを使うのが一般的である

# 3章 合成型
## 配列
配列の宣言は
```
// ゼロ
var x [3]int
// [1, 2, 3]
var x = [3]int{1, 2, 3}
var x = [...]int{1, 2, 3}
// [1, 0, 10, 0, 11]
var x = [5]int{1, 2:10, 4: 11}
// ==, !=で比較可能
var y = [3]int{1,2,3}
fmt.Println(x == y)
// 多次元
var x [2][3]int
// len関数で配列の長さを調べる
fmt.Println(len(x))
```

Goでは、配列が直接使われることは多くない。長さが異なる配列への型変換もできないので、`[3]int` と `[4]int`では型が違うと見なされる。従って、配列はほとんど使われない。標準ライブラリの暗号処理関連の関数の中には例外的に配列を返すものもあるが。配列は、Goでよく使われる「スライス」の後方支援のために存在している。

## スライス
スライスは「可変長の配列」とも言える。宣言方法は配列と似ているが、長さを指定してはいけない。
sliceは以下のstructで定義されている
```
// https://github.com/golang/go/blob/master/src/runtime/slice.go より
type slice struct { 
	array unsafe.Pointer 
	len int 
	cap int 
}
```
```
var x = []int{1, 2, 3}
var x = []int{1, 5: 4, 6, 10:100, 15}
// 多次元スライス
var x [][]int
var x []int // スライスのゼロ値、すなわちnilが初期値になる
```
Go言語のnilはnullとは少し意味が違う。nilは「型がない」ことを示す識別子。リテラルの数値のように型が無い。従って、異なる型に代入したり、異なる型と比較したりできる。
スライスは比較可能ではない。比較できるのはnulかどうかだけ。なお、reflectのDeepEqualを使ってスライスを含め、ほとんど全てのものを比較できる。

組み込み関数としては、len()で長さを取得でき、appendで要素を追加できる。len(nil)は0になる。append(x, 5, 6, 7)のように、同時に複数の値も追加できる。
演算子「...」を利用してスライスを展開し、マージすることもできる
```
x := []int{5, 4}
append(x, 5, 6, 7)
var y = []int{3, 2, 1}
x = append(x, y...)
```
Go言語では関数に引数を渡す際には必ず値のコピーが作られてから渡される。appendにスライスを渡すときにも、実際に渡されるのはコピーである。appendはスライスのコピーに値を追加したものを返すので、スライスに値を追加したいときは改めてその変数に代入する必要がある。
Sliceは配列へのポインタ、Cap, Lenを持っていて、appendにはスライスのコピーが渡されるが、参照する配列に容量があればそこに値を追加するだけなので十分に高速。一方で、容量がない場合はキャパシティを確保しないといけないのでだいぶ遅くなる。キャパシティの確保には新しいarrayを作って値をコピーし、pointerを貼り直している。

makeを利用するとキャパシティを指定してスライスを作ることができる。
以下は長さとキャパシティが両方5
```
x := make([]int, 5)
```
上の、makeを使って生成したスライスの要素にappendで値を入れるのは間違い。
```
x := make([]int, 5)
x = append(x, 10) // [0, 0, 0, 0, 0, 10]になってしまう。
```
以下は長さが0でキャパシティが5にappendで値を入れた例。これは合ってる
```
x := make([]int, 0, 5)
// 要素を追加してみる
x = append(x, 1, 2, 3, 4)
fmt.Println(x) // [1, 2, 3, 4]
```

Go言語では、スライスからスライスを切り出すことができる。
```
x := []int{1, 2, 3, 4}
y := x[:2]
z := x[1:]
d := x[1:3]
e := x[:]
fmt.Println("x:", x) // x: [1 2 3 4]
fmt.Println("y:", y) // y: [1 2]
fmt.Println("z:", z) // z: [2 3 4]
fmt.Println("d:", d) // d: [2 3]
fmt.Println("e:", e) // e: [1 2 3 4]
```
スライスからスライスを切り出す際にはデータのコピーを作っているわけでは無いので、要素を変更すると共有している全てのスライスが影響を受ける。
```
x := []int{1, 2, 3, 4} y := x[:2]  
z := x[1:]  
x[1] = 20

y[0] = 10
z[1] = 30
fmt.Println("x:", x) // x: [10 20 30 4]
fmt.Println("y:", y) // y: [10 20]
fmt.Println("z:", z) // z: [20 30 4]
```
また、スライスのスライスではキャパシティ部分も共有されるため、appendを使うとややこしいことになる。
```
x := []int{1, 2, 3, 4}  
y := x[:2]  
fmt.Println(cap(x), cap(y)) // 4 4 
y = append(y, 30)
fmt.Println("x:", x) // x: [1 2 30 4]
fmt.Println("y:", y) // y: [1 2 30]
```
yはサイズ2, キャパシティ4に設定されるので、30をappendするとxの3が入っていた場所が上書きされてしまう。
appendの問題についてはフルスライス式という解決策がある。キャパシティをスライスのスライスの長さに明示的に指定してあげることで、appendした際に新しくメモリを確保してくれて干渉を防ぐことができる。
```
x := []int{1, 2, 3, 4}
y := x[:2:2]
fmt.Println(cap(x), cap(y)) // 4 4
y = append(y, 30)
fmt.Println("x:", x) // x: [1 2 3 4]
fmt.Println("y:", y) // y: [1 2 30]
```

配列からスライスを取ることも同様の方法で可能。
メモリを共有しないスライスの生成では、makeと組み込みのcopyを利用する。copyの戻り値はコピーされた要素数で、appendと違ってyを代入しなくてもコピーできるので注意。コピーされた要素が不要なら戻り値を代入しなくても良い。
```
x := []int{1, 2, 3, 4} // オリジナルのスライス
y := make([]int, 4)    // 長さ4のスライスy
num := copy(y, x)
fmt.Println(num, y)
```
また、copy(y, x\[2:\])のようにして途中を切り抜くことも可能

Go言語の文字列はruneから作られていると思われるかもしれないが、そうではなく、バイト列を利用している。以下のように、スライスと同様に一つの文字を抽出できる。スライス式も利用できる。
```
var s string = "Hello there" 
var b byte = s[6]
var s2 string = s[4:7] // o t
```
UTF8のコードポイントは1バイトから4バイトの長さがあり、☀️などは3バイト持っているので、長さが変わってくる。utf8.RuneCountInStringを利用すると文字列が取れる。
```
var s string = "Hello ☀" 
fmt.Println(len(s)) // 7ではなく9が出力される
```
rune, バイトは文字列に変換可能。stringはrune列, バイト列に変換可能
UTF8は文字列の途中にランダムにアクセスできない（1バイト以外の文字が混ざっている場合）。

var nilMap map\[int\]string これは初期値がnil。
マップリテラルを使った宣言ができる
```
totalWins := map[string]int{}
// 文字列のスライスをvalueに持つ
ma := map[string][]string{
	"fruits": []string{"apple", "grape"},
	"colours": []string{"red", "blue"},
}
// マップのサイズがある程度予測できる場合は、サイズを指定してmakeを呼び出す。
ages := make(map[string]int, 10)
```
mapに指定されていないキーを取得するとゼロ値が返ってくるが、カンマOKイディオムで、0が指定されているのか、キーが存在しないのか判断可能
```
m := map[string]int{
	"hello": 5,
	"world": 0,
}
v, ok := m["world"] // 0, true
fmt.Println(v, ok)
v, ok = m["orange"] // 0, false
fmt.Println(v, ok)
```
delete関数で削除可能。deleteは何も返さないし、セットされていない値を削除しようとしても何もならない。
```
delete(m, "hello")
```
goにはセットはデフォルトではないが、mapでエミュレート可能。ただし、mapのキーは比較可能なものしか入らないので、スライスやmapをキーとすることはできない。struct{}を利用して1バイト削ることもできる（boolは1バイトで、struct{}は0バイトである）が、読みにくさからほとんどの場合は推奨されない。
次、3.5構造体から